#!/bin/bash

# TODO:
#   - Provide output confirming when a snap is installed.
#   - What to do about snaps that require manually plug/slot connections? (Ex.?)
#   - Add ability for user manage snapd settings.

# ===========================================================================
# Purpose:
#   - Provide for installing, updating, and removing snap packages without
#       an internet connection.
# Goals:
#   - Accept an argument indicating a folder where snaps and asserts are kept.
#   - Guide the user to select such a folder when there is no argument.
#   - Present a list of snaps to install or update, allowing the user to select
#       from among them.
#   - Ensure that the core snap is installed/updated first.
#   - Ensure that snaps will be able to receive automatic updates, as if they
#       were installed directly from the snap store.
#   - Allow user to manage snapd settings, such as refresh timer, metered
#       connections, number of revisions kept.
# ===========================================================================


# ---------------------------------------------------------------------------
# Set global variables.
# ---------------------------------------------------------------------------
USAGE_TEXT="usage: $0 [-h] | [-i] [-s /path/to/dir] [snap name(s)...]"
HELP_TEXT="$USAGE_TEXT

This app updates snap apps. The updates can come from the internet, a directory,
or both. If no options or args are passed, update information will be requested
interactively. If no snap names are given, then updates are attempted for all
installed snaps.

    -h                  Show this help text.
    -i                  Search online for updates.
    -s  /path/to/dir    Look for downloaded updates in /path/to/dir.
    snap1 snap2 ...     Space-separated list of snaps to install or update.

"

# Empty intial value for $SNAPS_DIR.
SNAPS_DIR=''

# Initial value for online source.
INET=0
OFFL=0


# ---------------------------------------------------------------------------
# Parse options passed.
# ---------------------------------------------------------------------------
while getopts ":his:" opt; do
    case $opt in
        h) # help requested
            echo "$HELP_TEXT"
            exit 0
            ;;
        i) # check internet for updates
            INET=2
            ;;
        s) # source directory option passed
            SNAPS_DIR=$(realpath "$OPTARG")
            OFFL=1
            ;;
        /?) # invalid option
            echo "$USAGE_TEXT"
            exit 1
    esac
done
shift $((OPTIND-1))

# System info
LOG_DATE=$(date +%F-%H-%M)
HOST=$(uname -n)

# PolicyKit root app path.
AS_ROOT=/usr/bin/wasta-snap-manager-root

# Starting value for determining update sources.
SUM=$(($INET + $OFFL))

# Zenity defaults
ZTITLE="Wasta [Snap] Manager"
ZHEIGHT=450
ZWIDTH=650
ZICON=/usr/share/icons/hicolor/64x64/apps/wasta-offline.png
ZICNM=wasta-offline
ZDEFAULTS=(
    --title="$ZTITLE" --height="$ZHEIGHT" --width="$ZWIDTH" \
    --window-icon="$ZICON" --icon-name="$ZICNM"
    )


# ---------------------------------------------------------------------------
# Define functions.
# ---------------------------------------------------------------------------
ask_offline_folder() {
    # Ask user for offline folder location if not passed as argument.
    offl="$1"
    snaps_dir="$2"

    if [[ ! $snaps_dir ]] && [[ $offl -eq 1 ]]; then
        # Determine potential $START_FOLDER.
        text="\n\n\nSearching system for wasta [Offline] folder..."
        prog_opts=(--progress --pulsate --auto-close --auto-kill --no-cancel)
        # Convoluted yet functional zenity subprocess inspired by this article:
        #   http://wiki.bash-hackers.org/zenity_--progress
        wo_list=$(
            find /media /mnt /home/"$USER" -not -path '*/.*' \
                -name 'wasta-offline' -type d 2>/dev/null | tee >(
                    zenity "${prog_opts[@]}" --text="$text" "${ZDEFAULTS[@]}" \
                        --height=250 2>/dev/null
                    )
        )
        if [[ -z $wo_list ]]; then
            START_FOLDER=/home/"$USER"/
        else
            for d in ${wo_list[@]}; do
                loc_cache=$(find "$d" -maxdepth 1 -name 'local-cache' -type d 2>/dev/null)
                if [[ $loc_cache =~ ^/media/.*$ ]]; then
                    # Automatically accept 'wasta-offline' folder in /media/...
                    START_FOLDER="$d"
                    # Title for upcoming file chooser dialog.
                    title="Confirm the wasta-offline folder or choose another one"
                    break
                elif [[ $loc_cache ]]; then
                    # Accept other 'wasta-offlne' folder, but let one in /media/... overrule it.
                    #   In case there are more than two qualifiers, the last one found wins.
                    START_FOLDER="$d"
                    title="Confirm the wasta-offline folder or choose another one"
                else
                    # No "true" wasta-offline folder found.
                    START_FOLDER=/home/"$USER"/
                    title="Choose the offline snaps folder"
                fi
            done
        fi
        SNAPS_DIR=$(
            zenity --file-selection --directory --title="$title" \
                --filename="$START_FOLDER" 2>/dev/null
        )
        if [[ $? -ne 0 ]]; then
            # User clicked "Cancel". Exit.
            window_home "0"
        fi
    fi
}

create_log() {
    # Set log location.
    #   Needs to happen before $SNAPS_DIR adjustment below.
    #   Can't guarantee a $SNAPS_DIR if source is online only.
    sum="$1"
    SNAPS_DIR="$2"

    if [[ $SNAPS_DIR ]]; then
        LOG_DIR="$SNAPS_DIR/log/wasta-snap-manager"
    else
        LOG_DIR=/home/$USER/.log/wasta-snap-manager
    fi
    mkdir -p "$LOG_DIR"
    LOG="$LOG_DIR/$LOG_DATE-$HOST.log"

    # Need to be able to handle 2 types of SNAPS_DIRs:
    #   1. "wasta-offline" folder -> Set SNAPS_DIR as wasta-offline/local-cache/snaps.
    #   2. any other folder passed -> Set SNAPS_DIR as passed argument.
    if [[ $SNAPS_DIR =~ ^.*wasta-offline$ ]]; then
        SNAPS_DIR="$SNAPS_DIR"/local-cache/snaps
        # Make sure SNAPS_DIR exists.
        mkdir -p "$SNAPS_DIR"
    fi

    # Initial log entry
    echo "-------------------------------------------------------" | tee -a "$LOG"
    echo "*** Installing/updating snaps                          " | tee -a "$LOG"
    echo "-------------------------------------------------------" | tee -a "$LOG"

    # Note defined update source(s).
    echo "Update source(s):"                    | tee -a "$LOG"
    case $sum in
        1) # offline updates only
            echo "$SNAPS_DIR"                   | tee -a "$LOG"
            ;;
        2) # online updates only
            echo "Snap store."                  | tee -a "$LOG"
            ;;
        3) # offline and online updates
            echo "$SNAPS_DIR, then Snap store." | tee -a "$LOG"
    esac
    echo | tee -a "$LOG"
}

list_installed_snaps() {
    # Get list of snaps currently installed. Create global associative array
    #   of installed snaps and their revision numbers: $snaps_installed

    # Delete previous $snaps_installed.
    unset snaps_installed[@]

    # Recreate updated $snaps_installed.
    installed_list=$(snap list | grep -v Name)
    if [[ -w $LOG ]]; then
        echo -e "Installed snaps:\n$installed_list\n" | tee -a "$LOG"
    fi

    # Add these snap names to $snaps_installed dictionary.
    declare -Ag snaps_installed
    while read -r line; do
        name=$(echo "$line" | tr -s ' ' | cut -d' ' -f1)
        rev=$(echo "$line" | tr -s ' ' | cut -d' ' -f3)
        #fileloc=$SNAPS/${snap}_${rev}.snap
        #size=$(stat --printf="%s" "$fileloc")
        snaps_installed["$name"]="$rev"
    done <<< "$installed_list"
}

list_available_snaps() {
    snaps_dir="$1"

    # Get offline snaps in $SNAPS_DIR.
    available_list=$(find "$snaps_dir"/ -name '*.snap')

    # Build associative array of available snaps and revisions in SNAPS_DIR.
    #   The revision numbers are space-delimited; e.g. ("[skype]"="54 57 ").
    declare -A snaps_avail_all
    for i in ${available_list[@]}; do
        name_rev=${i##*/}
        name_rev=${name_rev%.snap}
        rev=${name_rev##*_}
        name=${name_rev%_*}
        snaps_avail_all["$name"]+="$rev "
    done

    # Sort revisions listed for each snap, choose highest one.
    declare -Ag snaps_available
    for name in ${!snaps_avail_all[@]}; do
        top=$(
            for r in ${snaps_avail_all[$name]}; do
                echo $r
            done | sort -nr | head -1
            )
        snaps_available["$name"]="$top"
    done
}

list_updatable_snaps() {
    declare -n inst="$1"
    declare -n avail="$2"

    # Find any $snaps_available newer than $snaps_installed.
    declare -Ag snaps_updatable
    for name in ${!inst[@]}; do
        inst_rev="${inst[$name]}"
        avail_rev="${avail[$name]}"
        if [[ $avail_rev -gt $inst_rev ]]; then
            snaps_updatable[$name]="$avail_rev"
        fi
    done
}

show_installed_snaps() {
    declare -n installed="$1"
    # Remove core snaps from list to avoid accidentally uninstalling them.
    # TODO: Obviously this will need to be revised for any future core snaps,
    #   but it seems unwise to try to match snaps beginning with 'core';
    #   e.g., corebird.
    unset installed['core'] installed['core18']

    # Build list for displaying installed snaps.
    list_installed_unsorted=( ${!installed[@]} )
    installed_sorted=( $(printf '%s\n' "${list_installed_unsorted[@]}" | sort) )

    installed_snaps=()
    for name in "${installed_sorted[@]}"; do
        rev="${installed[$name]}"
        installed_snaps+=( "True" "$name" "$rev" )
    done

    # Show zenity --checklist for user to choose updates/installs.
    text="<big><b>\
Installed snap packages.</b></big>\n
To uninstall snap packages, deselect them and click \"OK\"\n"
    kept_snaps=$(zenity --list --checklist "${ZDEFAULTS[@]}" \
        --title="Wasta [Snap] Manager" \
        --column='' --column="Snap" --column="Revision" \
        "${installed_snaps[@]}" --separator='\n' \
        --text="$text" --cancel-label="Back" 2>/dev/null
        )
    if [[ $? -eq 1 ]]; then
        # User clicked [Back].
        window_home "0"
    fi

    # Compare $installed_snaps with $kept_snaps to produce $snaps_to_remove
    snaps_to_remove=$(
        echo "${installed_sorted[@]}" "${kept_snaps[@]}" \
        | tr ' ' '\n' | sort | uniq -u
    )
}

remove_snaps() {
    declare -n to_remove="$1"

    # Elevate to root privileges before removing.
    pkexec "$AS_ROOT" elevate
    if [[ $? -eq 126 ]]; then
        # Removal cancelled.
        exit 1
    fi

    # Remove snaps.
    for name in ${to_remove[@]}; do
        # Output to progress dialog and to $LOG.
        echo "#Removing snaps.\n\n\n$name..."
        #echo -en "\tRemoving $name... " | tee -a "$LOG"

        pkexec "$AS_ROOT" snap remove "$name"
        if [[ $? -eq 126 ]]; then
            # Snap removal cancelled.
            exit 1
        fi
    done
}

show_offline_updates() {
    declare -n installed="$1"
    declare -n available="$2"
    declare -n updatable="$3"

    # Build list for displaying updatable and installable snaps.
    avail_unsorted=( ${!available[@]} )
    avail_sorted=( $(printf '%s\n' "${avail_unsorted[@]}" | sort) )

    available_snaps=()
    for name in "${avail_sorted[@]}"; do
        inst_rev="${installed[$name]}"
        avail_rev="${available[$name]}"
        if [[ ${installed[$name]} ]]; then
            if [[ ${updatable[$name]} ]]; then
                available_snaps+=( "True" "$name" "$inst_rev" "$avail_rev" )
            fi
        else
            available_snaps+=( "False" "$name" "-" "$avail_rev" )
        fi
    done

    # Show zenity --checklist for user to choose updates/installs.
    if [[ $available_snaps ]]; then
        text="<big><b>\
These offline snap packages are available for this computer.</b></big>
Available updates are already selected. New packages can be installed by selecting them as well."
        selected_snaps=$(zenity --list --checklist "${ZDEFAULTS[@]}" \
            --title="Wasta [Snap] Manager" \
            --ok-label="Add/Update" --cancel-label="Back" \
            --column='' --column="Snap" --column="Installed Revision" --column="Available Revision" \
            "${available_snaps[@]}" --separator='\n' \
            --text="$text" 2>/dev/null
            )
        ec=$?
        if [[ $ec -eq 1 ]]; then
            # User clicked Cancel. Go to Home Window.
            window_home "0"
        fi
    else
        text="<big><b>No updated snaps are available.</b></big>"
        zenity --info "${ZDEFAULTS[@]}" --width=350 --height=150 \
                --text="$text" 2>/dev/null
        window_home "0"
    fi
}

install_snaps() {
    declare -n available="$1"
    declare -n to_install="$2"
    snaps_dir="$3"

    # Elevate to root privileges before installing.
    if [[ ! $to_install ]]; then
        # No installs or updates selected.
        window_home "0"
    fi
    pkexec "$AS_ROOT" elevate
    if [[ $? -eq 126 ]]; then
        # Installation cancelled.
        exit 1
    fi

    for name in ${to_install[@]}; do
        rev="${available[$name]}"

        # Output to progress dialog and to $LOG.
        echo "#Installing/updating snaps from:\n\t$snaps_dir\n\n$name..."
        echo -en "Installing $name from offline source... " | tee -a "$LOG"
        # Acknowledge assertion.
        pkexec "$AS_ROOT" snap ack "$snaps_dir/${name}_${rev}.assert" #2>"$LOG"
        #--------------------------------------------------------------
        # Unfortunately, to find out if a downloaded snap requires
        # --classic confinement there seems to be two options:
        #       1. Install the snap first and let it fail, grep for
        #           'classic' in the error output
        #       2. Mount the snap file, cat /meta/snap.yaml, grep
        #           'confinement: classic', umount the image.
        # -------------------------------------------------------------
        # Install snap. Check change to see if error due to --classic flag.
        pkexec "$AS_ROOT" snap install "$snaps_dir/${name}_${rev}.snap" #2>"$LOG"
        if [[ $? -gt 0 ]]; then # failed to install
            change=$(snap changes | tail -n2 | head -1 | tr -s ' ' \
                | cut -d' ' -f1)
            # TODO: Does this work for other locales?
            needs_classic=$(snap change "$change" | tail -n2 | head -1 \
                | grep 'requires classic confinement')
            if [[ $needs_classic ]]; then
                # Attempt install again with --classic flag.
                echo "$needs_classic" | tee -a "$LOG"
                pkexec "$AS_ROOT" snap install $snaps_dir/${name}_${rev}.snap --classic
                if [[ $? -ne 0 ]]; then
                    # Unhandled error.
                    echo -e "error, skipped." | tee -a "$LOG"
                    continue
                else
                    echo -e "installed." | tee -a "$LOG"
                fi
            else
                # Some other install error.
                echo -e "error, skipped. " | tee -a "$LOG"
                continue
            fi
        else
            echo -e "installed." | tee -a "$LOG"
        fi
    done
}

window_home() {
    # If source(s) not given in options, ask for them interactively.
    sum="$1"
    snaps_dir="$2"

    if [[ $sum -eq 0 ]]; then

        text="<big><b>wasta [Snap] Manager</b>
Manage snap packages and snap update settings.</big>

To <b>Add/Update</b> snap packages, first choose your preferred source(s):
<i>If both are selected, the offline source will be used first to limit downloading.</i>"

        loc_text="Add/update snaps from wasta [Offline] or local folder."
        net_text="Update snaps from the online Snap Store."
        list=( "False" "1" "Offline" "$loc_text" "False" "2" "Online" "$net_text" )
        sources=$(zenity --list --checklist "${ZDEFAULTS[@]}" \
            --column='' --column=value --column=Source --column=Description \
            --hide-column=2 "${list[@]}" \
            --ok-label="Add/Update..." --cancel-label="Quit" \
            --extra-button="Remove..." --extra-button="Settings..." \
            --text="$text" --height=250 2>/dev/null)
        ec=$?
    fi

    # Proceed to window corresponding to chosen button.
    if [[ $ec -eq 1 ]] && [[ $sources ]]; then
        if [[ $sources == 'Remove...' ]]; then
            # User clicked [Remove...].
            window_remove_snaps
        elif [[ $sources == 'Settings...' ]]; then
            # User clicked [Settings...].
            echo "User clicked [Settings...]. Not yet implemented. Back to Home."
            window_home "0"
        fi
    elif [[ $ec -eq 1 ]]; then
        # User clicked [Quit] or the [x].
        exit 0
    fi
    # User clicked [Add/Update...]; $ec was 0

    # Restart window if no sources selected.
    if [[ ! $sources ]]; then
        window_home "0"
    fi

    # Add 0 ouput for unchecked boxes.
    if [[ "$sources" -eq 1 ]]; then
        sources="$sources|0"
    elif [[ "$sources" -eq 2 ]]; then
        sources="0|$sources"
    fi

    # Evaluate user's response.
    OFFL="${sources%|*}"
    INET="${sources#*|}"
    SUM=$(($INET + $OFFL))

    ask_offline_folder "$OFFL" "$snaps_dir"
    create_log "$SUM" "$SNAPS_DIR"
    window_add_or_update_snaps "$SNAPS_DIR" "$SUM"
}

window_settings() {
    # https://forum.snapcraft.io/t/system-options/87
    echo "<Settings window not yet implemented>"
    window_home "0" "$SNAPS_DIR"
    return
    # Elevate to root privileges before opening window.
    pkexec "$AS_ROOT" elevate
    if [[ $? -eq 126 ]]; then
        # User cancelled authorization window.
        exit 1
    fi

    # Build list of current settings. This list includes:
    #   - handling of metered connections, $m_handling
    #   - current connection metered status, $c_metered
    #   - snap automatic refresh timer, $r_timer
    #   - number of total snap revisions to keep, $r_kept

    # Record defaults.
    m_handling_def=null
    m_handling_sug=hold
    c_metered_def='unknown'
    c_metered_sug='yes'
    r_timer_def='00:00~24:00/4'
    r_timer_sug='sun5,02:00'
    r_kept_def=3
    r_kept_sug=2

    # Get current settings.
    pat='s/.*dev\s([0-9a-zA-Z]*).*/\1/'
    inet_device=$(
        ip route | grep 'default via' | head -1 | sed -r "$pat"
    )
    current_connection=$(
        nmcli -t -f GENERAL.CONNECTION --mode tabular dev show "$inet_device"
    )
    metered_status=$(
        nmcli -f connection.metered connection show "$current_connection" \
        | tr -s ' ' | cut -d' ' -f2
    )

    m_handling=$(pkexec "$AS_ROOT" snap get system refresh.metered 2>/dev/null)
    if [[ ! $m_handling ]]; then
        m_handling=null
    fi
    c_metered="$metered_status"
    r_timer=$(snap refresh --time | head -1 | sed -r 's/^timer: (.*)$/\1/')
    r_kept=$(pkexec "$AS_ROOT" snap get system refresh.retain 2>/dev/null)
    if [[ ! $r_kept ]]; then
        r_kept=3
    fi

    # Build list for zenity checklist window.
    settings=()
    # Add $c_metered details to the list.
    desc="Set current connection as metered"
    if [[ $c_metered == $c_metered_def ]]; then
        settings+=( "False" )
    else
        settings+=( "True" )
    fi
    settings+=( "connection.metered" "$desc" "$c_metered" "$c_metered_sug" )
    # Add $m_handling details.
    desc="Auto-refresh on metered connections"
    if [[ $m_handling == $m_handling_def ]]; then
        settings+=( "False" )
    else
        settings+=( "True" )
    fi
    settings+=( "refresh.metered" "$desc" "$m_handling" "$m_handling_sug" )
    # Add $r_timer details.
    desc="Auto-refresh time window"
    if [[ $r_timer == $r_timer_def ]]; then
        settings+=( "False" )
    else
        settings+=( "True" )
    fi
    settings+=( "refresh.timer" "$desc" "$r_timer" "$r_timer_sug" )
    # Add $r_kept details.
    desc="Number of snap revisions kept"
    if [[ $r_kept == $r_kept_def ]]; then
        settings+=( "False" )
    else
        settings+=( "True" )
    fi
    settings+=( "refresh.retain" "$desc" "$r_kept" "$r_kept_sug" )

    # Show zenity checklist window.
    text="<big><b>Manage snapd settings.</b></big>\n
Default settings are unchecked.
Check the box to apply suggested values. Uncheck it to restore defaults."
    override_defaults=$(zenity --list --checklist "${ZDEFAULTS[@]}" \
        --height=350 --title="Wasta [Snap] Manager" \
        --column='' --column="Setting" --column="Description" \
        --column="Current" --column="Suggested" \
        "${settings[@]}" --separator='\n' --cancel-label="Back" \
        --text="$text" 2>/dev/null
        )
    if [[ $? -eq 1 ]]; then
        # User clicked [Back].
        window_home "0"
    fi
    echo "${override_defaults[@]}"

    # Apply settings.
    setting_names=( "connection.metered" "refresh.metered" "refresh.timer" "refresh.retain" )
    # TODO: There's a syntax error somewhere in here, but I don't know where.
    #for s in "${setting_names[@]}"; do
    #    for o in "${override_defaults[@]}"; do
    #        if [[ $s == 'connection.metered' ]]; then
    #            if [[ $s == $o ]]; then
    #                echo "Set $s to $c_metered_sug"
    #            else
    #                continue
    #            fi
    #        elif [[ $s == 'refresh.metered' ]]; then
    #            if [[ $s == $o ]]; then
    #                echo "Set $s to $m_handling_sug"
    #            else
    #                continue
    #            fi
    #        elif [[ $s == 'refresh.timer' ]]; then
    #            if [[ $s == $o ]]; then
    #                echo "Set $s to $r_timer_sug"
    #            else
    #                continue
    #            fi
    #        elif [[ $s == 'refresh.retain' ]]; then
    #            if [[ $s == $o ]]; then
    #                echo "Set $s to $r_kept_sug"
    #            else
    #                continue
    #            fi
    #        else
    #            continue
    #        fi
    #    done
    #done

    exit 0
    # Set current connection to metered.
    nmcli connection modify "$current_connection" connection.metered yes
    # Revert $current_connection to default "unknown" metered setting.
    #nmcli connection modify "$current_connection" connection.metered unknown

    # "Hold" (i.e "stop") refreshes when on metered connnections.
    #   It's up to NetworkManager to determine whether a connection is metered.
    #   Of course, the user can also explicity set a connection as metered.
    #pkexec "$AS_ROOT" snap set system refresh.metered=hold
    # Revert to default setting.
    #pkexec "$AS_ROOT" snap set system refresh.metered=null

    # Effectively block refreshes by setting the refresh timer to sun5,02:00.
    #   This refers to the last Sunday of the month at 2am.
    timer=$(snap refresh --time | head -1 | sed -r 's/^timer: (.*)$/\1/')
    timer_default='00:00~24:00/4'
    timer_off='sun5,02:00'
    #pkexec "$AS_ROOT" snap set system refresh.timer="$timer_off"
    # Revert to default setting.
    #pkexec "$AS_ROOT" snap set system refresh.timer="$timer_default"

    # Choose number of previous snap revisions to keep. Default is 3.
    #pkexec "$AS_ROOT" snap set system refresh.retain=2
    # Revert to default setting.
    #pkexec "$AS_ROOT" snap set system refresh.retain=3
}

# Show window of available snaps to update or install.
window_add_or_update_snaps() {
    # This function takes 'offline_mode' and $SNAPS_DIR as arguments.
    #   It lets the user install or update snaps both offline and online.
    snaps_dir="$1"
    install_mode="$2"

    # Prepare to add/update snaps from offline source if chosen.
    if [[ ! $install_mode -eq 2 ]]; then
        list_installed_snaps                                     # -> $snaps_installed
        list_available_snaps "$snaps_dir"                        # -> $snaps_available
        list_updatable_snaps "snaps_installed" "snaps_available" # -> $snaps_updatable
        show_offline_updates "snaps_installed" "snaps_available" "snaps_updatable" # -> $selected_snaps

        # Install offline snaps; show progress window.
        prog_opts=(--progress --pulsate --auto-close --no-cancel)
        install_snaps "snaps_available" "selected_snaps" "$snaps_dir" \
            | zenity "${prog_opts[@]}" "${ZDEFAULTS[@]}" --height=250 \
                --text="Waiting for authorization..." 2>/dev/null
    fi

    # Refresh snaps if $INET=2; show progress window.
    if [[ $install_mode -gt 1 ]]; then
        echo "<Run snap refresh> with zenity progress window."
    fi

    # Send status message back to Home Window.
    status="Adding and/or updating snaps completed."

    # Return to Offline Updates Window.
    window_add_or_update_snaps "$snaps_dir" "$install_mode"
}

# Show window of installed snaps & allow for their removal.
window_remove_snaps() {
    # This function takes no arguments. It lets the user uncheck installed
    #   snaps in order to uninstall them. It can also be used to simply show
    #   a list of installed snaps.
    LOG='' # not going to log snap removals
    list_installed_snaps # -> $snaps_installed
    show_installed_snaps "snaps_installed" # -> $snaps_to_remove

    # Remove snaps; show progress window.
    prog_opts=(--progress --pulsate --auto-close --no-cancel)
    remove_snaps "snaps_to_remove" \
        | zenity "${prog_opts[@]}" "${ZDEFAULTS[@]}" --height=250 \
            --text="Waiting for authorization..." 2>/dev/null

    # Return to Remove Snaps Window.
    window_remove_snaps
}

idea_for_avoiding_subshells() {
    echo "Take a look at the comments."
    #bar () { echo "$BASH_SUBSHELL $BASHPID"; }
    #mkfifo /tmp/myfifo
    #exec 3<> /tmp/myfifo
    #bar 1>&3
    #read -u3 a
    #echo $a
    #0 8215
    #exec 3>&-
    #rm /tmp/myfifo
}


# ---------------------------------------------------------------------------
# Main processing.
# ---------------------------------------------------------------------------

# If folder argument is passed, go directly to installing or updating snaps.
if [[ $OFFL -eq 1 ]]; then
    create_log "$SUM" "$SNAPS_DIR"
    window_add_or_update_snaps "$SNAPS_DIR" "$INET"
    exit 0
else
    # Launch main window.
    window_home "$SUM" "$SNAPS_DIR"
fi

exit 0

#############################################################################
#############################################################################
# The rest is previous code still being worked back in.
#

# Determine list of snaps to update or install.
# ---------------------------------------------------------------------------
if [[ $@ ]]; then
    # Including core snaps in case they aren't yet installed or up-to-date.
    update_list="core core18 $@"
else # Get list of all installed snaps for updating.
    update_list=$(snap list | grep -v Name | grep -v disabled \
        | tr -s ' ' | cut -d' ' -f1)
fi

# Parse info for snaps to be installed or updated.
for snap in $update_list; do
    echo -n "Checking $snap... " | tee -a "$LOG"

    # Get local installed status and revision info.
    inst_rev=0

    # Command block around command substitution allows to send the output of
    #   the command to both stdout (via /dev/fd/5) AND assign it to a variable.
    #   https://stackoverflow.com/questions/12451278/capture-stdout-to-a-variable-but-still-display-it-in-the-console
    {
    inst_info=$(
        # Using tee to send /dev/fd/1 both to zenity progress and /dev/fd/5.
        snap info $snap 2>/dev/null | grep -v disabled | grep 'installed:' \
        | tee >(zenity --progress --pulsate --auto-close "${ZDEFAULTS[@]}" \
            --text="Checking $snap install status..." 2>/dev/null) \
            /dev/fd/5
        )
    # Redirect /dev/fd/5 to /dev/fd/1 to "export" variables from command block.
    } 5>&1

    if [[ $inst_info ]]; then
        # Snap is installed.
        inst_status=1
        inst_rev=$(echo $inst_info | sed -r 's/.*\(([0-9]*)\).*/\1/')
    else # snap not installed
        echo "not installed." | tee -a "$LOG"
        inst_status=0
    fi

    # If offline mode selected, update/install from $SNAPS_DIR if available.
    #   If online mode is also chosen, this could lead to a snap being updated
    #   twice, but that should also reduce the amount needed to be downloaded
    #   since it will only download delta changes since the offline version.
    if [[ $OFFL -eq 1 ]]; then
        # List all revisions of current snap.
        filepaths=$(find $SNAPS_DIR/${snap}_*.snap 2>/dev/null)
        ec=$?

        # Choosing the last entry found ensures the highest revision number.
        filepath=$(echo "$filepaths" | tail -n1)
        if [[ $ec -eq 0 ]]; then # snap found in $SNAPS_DIR
            # Get snap revision #.
            filename=${filepath##*/}
            snap_rev=${filename%.*}
            offl_rev=${snap_rev##*_}
            if [[ $inst_status -eq 0 ]]; then
                # Command block for zenity progress.
                {
                echo "#Installing $snap from $SNAPS_DIR... "
                # Need to install snap.
                echo -en "\tInstalling $snap from local source... " | tee -a "$LOG"
                snap ack $SNAPS_DIR/${snap}_${offl_rev}.assert
                #--------------------------------------------------------------
                # Unfortunately, to find out if a downloaded snap requires
                # --classic confinement there seems to be two options:
                #       1. Install the snap first and let it fail, grep for
                #           'classic' in the error output
                #       2. Mount the snap file, cat /meta/snap.yaml, grep
                #           'confinement: classic', umount the image.
                # -------------------------------------------------------------
                # Install snap. Check change to see if error due to --classic flag.
                snap install $SNAPS_DIR/${snap}_${offl_rev}.snap
                if [[ $? -gt 0 ]]; then # failed to install
                    change=$(snap changes | tail -n2 | head -1 | tr -s ' ' \
                        | cut -d' ' -f1)
                    # TODO: Does this work for other locales?
                    needs_classic=$(snap change "$change" | tail -n2 | head -1 \
                        | grep 'requires classic confinement')
                    if [[ $needs_classic ]]; then
                        # Attempt install again with --classic flag.
                        echo "$needs_classic" | tee -a "$LOG"
                        snap install $SNAPS_DIR/${snap}_${offl_rev}.snap --classic
                        if [[ $? -ne 0 ]]; then
                            # Unhandled error.
                            echo -e "\tUnhandled error. Skipped." | tee -a "$LOG"
                            continue
                        else
                            echo -e "\t$snap installed." | tee -a "$LOG"
                        fi
                    else
                        # Some other install error.
                        echo "Error: skipping. " | tee -a "$LOG"
                        continue
                    fi
                fi
                } | zenity --progress --pulsate --auto-close "${ZDEFAULTS[@]}" 2>/dev/null
                inst_status=1
                inst_rev=$offl_rev
            else
                {
                echo "#Updating $snap from $SNAPS_DIR... "
                if [[ $offl_rev -gt $inst_rev ]]; then
                    # TODO: Test if this actually works when user data is involved.
                    echo -en "\tUpdating $snap from local source..." | tee -a "$LOG"
                    snap ack "$SNAPS_DIR/${snap}_${offl_rev}.assert"
                    # TODO: Does this work with a --classic snap update? (skype, snapcraft)
                    snap install "$SNAPS_DIR/${snap}_${offl_rev}.snap"
                else
                    echo -en "\tNo local updates available. " | tee -a "$LOG"
                    # Give enough time for the user to see it looking for an update.
                    sleep 1.5
                fi
                } | zenity --progress --pulsate --auto-close "${ZDEFAULTS[@]}" 2>/dev/null
            fi
        else # not found in $SNAPS_DIR
            echo -en "\tNo local updates available. " | tee -a "$LOG"
        fi
    fi

    # If online mode is selected, update/install from internet if available.
    if [[ $INET -eq 2 ]]; then
        # Get latest stable revision number online.
        inet_info=$(snap info "$snap" | grep ' stable:')
        ec=$?
        # Determine confinement and install/update snap.
        if [[ $ec -eq 0 ]]; then # snap found online
            # Determine if snap requires classic confinement (ala skype)
            if [[ $(echo "$inet_info" | grep classic) ]]; then
                confinement="--classic"
            else
                confinement=''
            fi

            if [[ $inst_status -eq 1 ]]; then
                {
                echo "#Updating $snap from Snap store... "
                # Snap is already installed. It just needs to be "refreshed".
                echo "Updating $snap from the Snap store..." | tee -a "$LOG"
                snap refresh "$snap"
                } | zenity --progress --pulsate --auto-close "${ZDEFAULTS[@]}" 2>/dev/null
            else
                {
                # Snap is not installed.
                echo "#Installing $snap from the Snap store..."
                echo "Installing $snap from the Snap store..." | tee -a "$LOG"
                if [[ $confinement ]]; then
                    snap install "$snap" "$confinement"
                else
                    snap install "$snap"
                fi
                } | zenity --progress --pulsate --auto-close "${ZDEFAULTS[@]}" 2>/dev/null
            fi
        else
            # Snap not found. No internet connection? Snap not available?
            echo "Error: $snap not found." | tee -a "$LOG"
            exit 1
        fi
    else
        echo | tee -a "$LOG" # adds final \n to output
    fi
done


exit 0
