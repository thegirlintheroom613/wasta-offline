#!/bin/bash

# TODO:
#   - Some kind of integrity check for assert files? The ack command can
#       fail, causing the install window to hang if the assert file is malformed.

# ===========================================================================
# Purpose:
#   - Provide for installing, updating, and removing snap packages without
#       an internet connection.
# Goals:
#   - Accept an argument indicating a folder where snaps and asserts are kept.
#   - Guide the user to select such a folder when there is no argument.
#   - Present a list of snaps to install or update, allowing the user to select
#       from among them.
#   - Ensure that the core snap(s) is/are installed/updated first.
#   - Ensure that prerequisite snaps are installed.
#   - Ensure that snaps will be able to receive automatic updates, as if they
#       were installed directly from the snap store.
#   - Allow user to manage snapd settings, such as refresh timer, metered
#       connections, number of revisions kept.
# ===========================================================================


# ---------------------------------------------------------------------------
# Set global variables.
# ---------------------------------------------------------------------------
USAGE_TEXT="usage: $0 [-h] | [-i] [-s /path/to/dir] [snap name(s)...]"
HELP_TEXT="$USAGE_TEXT

This app updates snap apps. The updates can come from the internet, a directory,
or both. If no options or args are passed, update information will be requested
interactively. If no snap names are given, then updates are attempted for all
installed snaps.

    -h                  Show this help text.
    -i                  Search online for updates.
    -s  /path/to/dir    Look for downloaded updates in /path/to/dir.
    snap1 snap2 ...     Space-separated list of snaps to install or update.

"

# Variables and script needed for localization.
export TEXTDOMAINDIR=/usr/share/locale
#export TEXTDOMAINDIR=~/.local/share/locale # for user test installation
export TEXTDOMAIN=wasta-snap-manager
. gettext.sh

# Empty intial value for $SNAPS_DIR.
SNAPS_DIR=''

# Initial value for online source.
INET=0
OFFL=0

# ---------------------------------------------------------------------------
# Parse options passed.
# ---------------------------------------------------------------------------
while getopts ":his:" opt; do
    case $opt in
        h) # help requested
            echo "$HELP_TEXT"
            exit 0
            ;;
        i) # check internet for updates
            INET=2
            ;;
        s) # source directory option passed
            SNAPS_DIR=$(realpath "$OPTARG")
            OFFL=1
            ;;
        /?) # invalid option
            echo "$USAGE_TEXT"
            exit 1
    esac
done
shift $((OPTIND-1))

if ! [ $(which snap) ]; then
  echo "Snap is not installed yet.  (sudo apt-get install snapd) : Exiting..."
  exit 1
fi

# System info
LOG_DATE=$(date +%F-%H-%M)
HOST=$(uname -n)

# PolicyKit root app path. Using "which" allows for testing from alternate path.
AS_ROOT=$(which wasta-snap-manager-root)

# Starting value for determining update sources.
SUM=$(($INET + $OFFL))

# Zenity defaults
ZTITLE="$(gettext "wasta [Snap] Manager")"
ZHEIGHT=450
ZWIDTH=650
ZICON=/usr/share/icons/hicolor/scalable/apps/wasta-offline.svg
ZICNM=wasta-offline
ZDEFAULTS=(
    --title="$ZTITLE" --height="$ZHEIGHT" --width="$ZWIDTH" \
    --window-icon="$ZICON" #--icon-name="$ZICNM"
)
ZPROGDEFS=(
    --progress --pulsate --height=175 --auto-close
)

# Core snaps assumed.
# TODO: Need to add core20 once it's released.
# $ snap search core | grep canonical | grep -E '^core[0-9]*' | awk '{print $1}'
# core
# core18
# core16
CORES=( core core18 )


# ---------------------------------------------------------------------------
# Define functions.
# ---------------------------------------------------------------------------
ask_offline_folder() {
    # Ask user for offline folder location if not passed as argument.
    offl="$1"
    snaps_dir="$2"

    if [[ ! $snaps_dir ]] && [[ $offl -eq 1 ]]; then
        # Determine potential $START_FOLDER.
        text="$(gettext "\n\n\nSearching system for wasta [Offline] folder...")"
        # Convoluted yet functional zenity subprocess inspired by this article:
        #   http://wiki.bash-hackers.org/zenity_--progress
        wo_list=$(
            find /media /mnt /home/"$USER" -maxdepth 3 -not -path '*/.*' \
                -name 'wasta-offline' -type d 2>/dev/null | tee >(
                    zenity --text="$text" "${ZDEFAULTS[@]}" "${ZPROGDEFS[@]}" \
                        --auto-kill --no-cancel 2>/dev/null
                    )
        )
        if [[ -z $wo_list ]]; then
            START_FOLDER=/home/"$USER"/
        else
            while IFS= read -r d; do
                loc_cache=$(find "$d" -maxdepth 1 -name 'local-cache' -type d 2>/dev/null)
                # Title for upcoming file chooser dialog.
                title="$(gettext "Confirm the wasta-offline folder or choose another one")"
                if [[ $loc_cache =~ ^/media/.*$ ]]; then
                    # Automatically accept 'wasta-offline' folder in /media/...
                    START_FOLDER="$d"
                    break
                elif [[ $loc_cache ]]; then
                    # Accept other 'wasta-offlne' folder, but let one in /media/... overrule it.
                    #   In case there are more than two qualifiers, the last one found wins.
                    START_FOLDER="$d"
                else
                    # No "true" wasta-offline folder found.
                    START_FOLDER=/home/"$USER"/
                    title="$(gettext "Choose the offline snaps folder")"
                fi
            done <<< "${wo_list[@]}"
        fi
        SNAPS_DIR=$(
            zenity --file-selection --directory --title="$title" \
                --filename="$START_FOLDER" 2>/dev/null
        )
        if [[ $? -ne 0 ]]; then
            # User clicked "Cancel". Exit.
            window_home "0"
        fi
    fi
}

create_log() {
    # Set log location.
    #   Needs to happen before $SNAPS_DIR adjustment below.
    #   Can't guarantee a $SNAPS_DIR if source is online only.
    sum="$1"
    SNAPS_DIR="$2"

    if [[ $SNAPS_DIR ]]; then
        LOG_DIR="$SNAPS_DIR/log/wasta-snap-manager"
    else
        LOG_DIR=/home/$USER/.log/wasta-snap-manager
    fi
    mkdir -p "$LOG_DIR"
    LOG="$LOG_DIR/$LOG_DATE-$HOST.log"

    # Need to be able to handle 2 types of SNAPS_DIRs:
    #   1. "wasta-offline" folder -> Set SNAPS_DIR as wasta-offline/local-cache/snaps.
    #   2. any other folder passed -> Set SNAPS_DIR as passed argument.
    if [[ $SNAPS_DIR =~ ^.*wasta-offline$ ]]; then
        SNAPS_DIR="$SNAPS_DIR"/local-cache/snaps
        # Make sure SNAPS_DIR exists.
        mkdir --mode=777 --parents "$SNAPS_DIR"
    fi

    # Initial log entry
    echo "-------------------------------------------------------" | tee -a "$LOG"
    echo "*** Installing/updating snaps                          " | tee -a "$LOG"
    echo "-------------------------------------------------------" | tee -a "$LOG"

    # Move wayward snaps to arch-specific subfolders.
    # TODO: This is transitional. The initial version of wasta-offline-snap-setup
    #   placed snaps of all architectures together in the same folder.
    if [[ $(which wasta-off-snap-cleanup) ]]; then
        wasta-off-snap-cleanup "$SNAPS_DIR"
    fi

    snap --version | tee -a "$LOG"
    echo | tee -a "$LOG"

    # Note defined update source(s).
    echo "Update source(s):"                    | tee -a "$LOG"
    case $sum in
        1) # offline updates only
            echo "$SNAPS_DIR"                   | tee -a "$LOG"
            ;;
        2) # online updates only
            echo "Snap store."                  | tee -a "$LOG"
            ;;
        3) # offline and online updates
            echo "$SNAPS_DIR, then Snap store." | tee -a "$LOG"
    esac
    echo | tee -a "$LOG"
}

get_installed_revision_number() {
    # Returns revision number of installed snap.
    name="$1"
    revision=$(snap list $name 2>/dev/null | tail -n +2 | tr -s ' ' | cut -d' ' -f3)
    if [[ $revision ]]; then
        echo "$revision"
        return 0
    else
        return 1
    fi
}

get_snap_arch() {
    snap_rev="$1"
    snaps_dir="$2"
    location=$(find "$snaps_dir" -maxdepth 2 -name "$snap_rev"'*.snap')
    arch_path="${location%/*.snap}"
    arch="${arch_path##*/}"
    echo "$arch"
}

list_installed_snaps() {
    # Get list of snaps currently installed. Create global associative array
    #   of installed snaps and their revision numbers: $snaps_installed

    # Delete previous $snaps_installed.
    unset snaps_installed[@]

    # Recreate updated $snaps_installed.
    installed_list=$(snap list | tail -n +2)
    if [[ -w $LOG ]]; then
        echo -e "Installed snaps:\n$installed_list\n" >> "$LOG"
    fi

    # Add these snap names to $snaps_installed dictionary.
    declare -Ag snaps_installed
    if [[ ! $installed_list == '' ]]; then
        while read -r line; do
            name=$(echo "$line" | tr -s ' ' | cut -d' ' -f1)
            rev=$(echo "$line" | tr -s ' ' | cut -d' ' -f3)
            #fileloc=$SNAPS/${snap}_${rev}.snap
            #size=$(stat --printf="%s" "$fileloc")
            snaps_installed["$name"]="$rev"
        done <<< "$installed_list"
    fi
}

list_available_snaps() {
    snaps_dir="$1"

    # Get system architecture.
    sys_arch=$(dpkg --print-architecture)

    # Get offline snaps in $snaps_dir/all and $snaps_dir/$sys_arch.
    #   This mixes arch designations, but the correct arch will found again later.
    available_list=$(find "$snaps_dir/all" "$snaps_dir/$sys_arch" -name '*.snap')

    # Build associative array of available snaps and revisions in SNAPS_DIR.
    #   The revision numbers are space-delimited; e.g. ("[skype]"="54 57 ").
    declare -A snaps_avail
    while IFS= read -r i; do
        name_rev=${i##*/}
        name_rev=${name_rev%.snap}
        rev=${name_rev##*_}
        name=${name_rev%_*}
        snaps_avail["$name"]+="$rev "
    done <<< "${available_list[@]}"

    # Sort revisions listed for each snap, choose highest one.
    declare -Ag snaps_available
    for name in ${!snaps_avail[@]}; do
        top=$(
            for r in ${snaps_avail[$name]}; do
                echo $r
            done | sort -nr | head -1
        )
        snaps_available["$name"]="$top"
    done
}

list_updatable_snaps() {
    declare -n inst="$1"
    declare -n avail="$2"

    # Find any $snaps_available newer than $snaps_installed.
    snaps_updatable=()
    for name in ${!inst[@]}; do
        inst_rev="${inst[$name]}"
        avail_rev="${avail[$name]}"
        if [[ $avail_rev -gt $inst_rev ]]; then
            snaps_updatable+=( "$name" )
        fi
    done
}

list_prerequisites() {
    # Find and list the given snap's prerequisites.
    snap_file="$1"
    arch="$2"
    unset snap_prereqs[@]
    declare -Ag snap_prereqs
    template="wo-yaml.XXXX"
    tmpd=$(mktemp -d "$template" --tmpdir)
    # Use unsquashfs to get snap.yaml contents.
    unsquashfs -force -dest "$tmpd" "$SNAPS_DIR/$arch/$snap_file" /meta/snap.yaml
    yaml="${tmpd}/meta/snap.yaml"
    #expr='s/.*:\s(.*)/\1/' # didn't omit parts; e.g. "default-provider: prereq:part"
    expr='s/.*:\s(.*)(:|$).*/\1/' # omits part if 2nd colon found
    base=$(cat "$yaml" | grep 'base:' | sed -r "$expr") # 0 or 1 line
    confinement=$(cat "$yaml" | grep 'confinement:' | sed -r "$expr") # 1 line
    prereqs=$(cat "$yaml" | grep 'default-provider:' | sed -r "$expr") # 0 to multiple lines

    # Add "default-provider" prereqs to array.
    if [[ $prereqs ]]; then
        for p in $prereqs; do
            snap_prereqs[$p]=''
        done
    fi

    rm -r "$tmpd"
}

show_installed_snaps() {
    declare -n installed="$1"
    # Remove core snaps from list to avoid accidentally uninstalling them.
    # TODO: Obviously this will need to be revised for any future core snaps,
    #   but it seems unwise to try to match snaps beginning with 'core';
    #   e.g., corebird.
    for c in ${CORES[@]}; do
        unset installed[$c]
    done

    # Build list for displaying installed snaps.
    list_installed_unsorted=( ${!installed[@]} )
    installed_sorted=( $(printf '%s\n' "${list_installed_unsorted[@]}" | sort) )

    installed_snaps=()
    for name in "${installed_sorted[@]}"; do
        rev="${installed[$name]}"
        installed_snaps+=( "True" "$name" "$rev" )
    done

    # Show zenity --checklist for user to choose updates/installs.
    text="<big><b>\
$(gettext "Installed snap packages.")</b></big>\n
$(gettext "To uninstall snap packages, deselect them and click") \"$(gettext "OK")\"\n"
    kept_snaps=$(zenity --list --checklist "${ZDEFAULTS[@]}" \
        --column='' --column="Snap" --column="Revision" \
        "${installed_snaps[@]}" --separator='\n' \
        --text="$text" --cancel-label="$(gettext "Back")" 2>/dev/null
    )
    if [[ $? -eq 1 ]]; then
        # User clicked [Back].
        window_home "0"
    fi

    # Compare $installed_snaps with $kept_snaps to produce $snaps_to_remove
    snaps_to_remove=$(
        echo "${installed_sorted[@]}" "${kept_snaps[@]}" \
        | tr ' ' '\n' | sort | uniq -u
    )
}

remove_snaps() {
    declare -n to_remove="$1"

    # Elevate to root privileges before removing.
    pkexec "$AS_ROOT" elevate
    if [[ $? -eq 126 ]]; then
        # Removal cancelled.
        exit 1
    fi

    # Remove snaps.
    for name in ${to_remove[@]}; do
        # Output to progress dialog.
        echo "#Removing snaps.\n\n\nRemoving $name..."
        echo -en "Removing $name... " | tee -a "$LOG"

        pkexec "$AS_ROOT" snap remove "$name"
        ret=$?
        if [[ $ret -eq 126 ]]; then
            # Snap removal cancelled.
            echo -e "cancelled." | tee -a "$LOG"
            exit 1
        elif [[ $ret -gt 0 ]]; then
            echo "ret: $ret" | tee -a "$LOG"
            # Some other error.
            echo -e "error, skipped." | tee -a "$LOG"
            continue
        else
            # Snap removed successfully.
            echo -e "removed." | tee -a "$LOG"
        fi
    done

    echo | tee -a "$LOG"
}

show_offline_updates() {
    declare -n installed="$1"
    declare -n available="$2"
    declare -n updatable="$3"

    # Build list for displaying updatable and installable snaps.
    avail_unsorted=( ${!available[@]} )
    avail_sorted=( $(printf '%s\n' "${avail_unsorted[@]}" | sort) )

    available_snaps=()
    for name in "${avail_sorted[@]}"; do
        inst_rev="${installed[$name]}"
        avail_rev="${available[$name]}"
        if [[ ${installed[$name]} ]]; then
            if [[ $(echo ${updatable[@]} | grep $name) ]]; then
                available_snaps+=( "True" "$name" "$inst_rev" "$avail_rev" )
            fi
        else
            available_snaps+=( "False" "$name" "-" "$avail_rev" )
        fi
    done

    # Show zenity --checklist for user to choose updates/installs.
    if [[ $available_snaps ]]; then
        text="<big><b>\
$(gettext "These offline snap packages are available for this computer.")</b></big>
$(gettext "Available updates are already selected. New packages can be installed by selecting them as well.
If \"online updates\" has also been selected, updates will be searched from the Snap Store
once the offline updates are complete.")"
        selected_snaps=$(zenity --list --checklist "${ZDEFAULTS[@]}" \
            --ok-label="$(gettext "Continue...")" \
            --cancel-label="$(gettext "Back")" \
            --column='' --column="Snap" --column="$(gettext "Installed Revision")" \
            --column="$(gettext "Available Revision")" \
            "${available_snaps[@]}" --separator='\n' \
            --text="$text" 2>/dev/null
        )
        ret=$?
        if [[ $ret -eq 1 ]]; then
            # User clicked Cancel. Go to Home Window.
            window_home "0"
        fi
    else
        text="<big><b>No updated snaps are available.</b></big>"
        zenity --info "${ZDEFAULTS[@]}" --width=350 --height=150 \
                --text="$text" 2>/dev/null
        window_home "0"
    fi
}

install_cores() {
    # Install/update core snaps.
    for name in ${CORES[@]}; do
        # Test if core snap is available offline.
        if [[ ${available[$name]} ]]; then
            # Get revision number of available core snap.
            rev_avail="${available[$name]}"

            # Test if core snap is already installed.
            if [[ $(get_installed_revision_number $name) ]]; then
                # Core snap installed. Get revision number.
                rev_exist=$(get_installed_revision_number $name)
                if [[ $rev_exist -ge $rev_avail ]]; then
                    # Most-recent offline revision already installed.
                    continue
                fi
            fi

            # Output to progress dialog and to $LOG.
            echo "#$(gettext "Installing/updating snaps from:")\n\t$snaps_dir\n\n$(gettext "Installing") $name..."
            echo -en "$(gettext "Installing") $name $(gettext "from offline source")... " | tee -a "$LOG"

            # Get arch subfolder for snap.
            arch=$(get_snap_arch "${name}_${rev_avail}" "$snaps_dir")

            # Acknowledge assertion and install snap.
            pkexec "$AS_ROOT" snap ack "$snaps_dir/$arch/${name}_${rev_avail}.assert"
            pkexec "$AS_ROOT" snap install "$snaps_dir/$arch/${name}_${rev_avail}.snap" 2>/dev/null
            if [[ $? -gt 0 ]]; then
                # Some install error.
                change=$(snap changes | tail -n2 | head -1 | tr -s ' ' \
                    | cut -d' ' -f1)

                # Output to progress dialog and to $LOG.
                echo "#Error installing $name; installation skipped"
                echo -e "error, skipped.\n$change " | tee -a "$LOG"
                continue
            else
                echo -e "installed." | tee -a "$LOG"
            fi
        fi
    done
}

install_prerequisites() {
    echo "Installing prereqs" | tee -a "$LOG"
    declare -n prereqs="$1"

    #if [[ ! ${!prereqs[@]} ]]; then
    #    # No installs or updates selected.
    #    echo "No prerequisites to install." | tee -a "$LOG"
    #    return 0
    #fi

    # Elevate to root privileges before installing.
    pkexec "$AS_ROOT" elevate
    if [[ $? -eq 126 ]]; then
        # Installation cancelled.
        return 1
    fi

    for p in ${!prereqs[@]}; do
        ra="${available[$p]}"

        # Test if prerequisite is already installed.
        if [[ $(get_installed_revision_number $p) ]]; then
            # Prerequisite installed. Get revision number.
            ri=$(get_installed_revision_number $p)
            if [[ $ri -ge $ra ]]; then
                # Most-recent offline revision already installed.
                continue
            fi
        fi

        # Get arch subfolder for snap.
        arch=$(get_snap_arch "${p}_${ra}" "$snaps_dir")

        # Output to progress dialog and to $LOG.
        echo "#Installing/updating snaps from:\n\t$snaps_dir\n\nInstalling $p..."
        echo -en "Installing $p from offline source... " | tee -a "$LOG"
        pkexec "$AS_ROOT" snap ack "$snaps_dir/$arch/${p}_${ra}.assert" 2>"$LOG"
        ec=$?
        if [[ $ec -ne 0 ]]; then
            # Error during ack. Skip this snap.
            echo -e "error during ack, skipped. " | tee -a "$LOG"
            continue
        fi
        #nmcli networking off
        pkexec "$AS_ROOT" unshare -n snap install "$snaps_dir/$arch/${p}_${ra}.snap" #2>"$LOG"
        ec=$?
        #nmcli networking on
        if [[ $ec -gt 0 ]]; then # failed to install
            # Some other install error.
            echo -e "error during install, skipped. " | tee -a "$LOG"
            continue
        else
            echo -e "installed." | tee -a "$LOG"
        fi
    done
}

install_snaps() {
    # This function is only used to install offline snaps.
    declare -n available="$1"
    declare -n to_install="$2"
    snaps_dir="$3"

    if [[ ! ${to_install[@]} ]]; then
        # No installs or updates selected.
        echo "Nothing to install or update." | tee -a "$LOG"
        return 0
    fi

    # Elevate to root privileges before installing.
    pkexec "$AS_ROOT" elevate
    if [[ $? -eq 126 ]]; then
        # Installation cancelled.
        echo "Installation cancelled!" | tee -a "$LOG"
        return 1
    fi

    # Install/update core snaps.
    install_cores

    # Install/update selected snaps.
    for name in ${to_install[@]}; do

        rev="${available[$name]}"
        # Output to progress dialog and to $LOG.
        echo "#Installing/updating snaps from:\n\t$snaps_dir\n\nInstalling $name..."
        echo -en "Installing $name from offline source... " | tee -a "$LOG"

        # Get arch subfolder for snap.
        arch=$(get_snap_arch "${name}_${rev}" "$snaps_dir")

        # List and install prerequisites.
        list_prerequisites "${name}_${rev}.snap" "$arch"
        if [[ ! ${!snap_prereqs[@]} == '' ]]; then
            install_prerequisites "snap_prereqs"
        fi

        # Acknowledge assertion.
        pkexec "$AS_ROOT" snap ack "$snaps_dir/$arch/${name}_${rev}.assert" #2>"$LOG"

        # Force networking to be offline to avoid downloading snap prereqs.
        #nmcli networking off
        # UPDATE: Attempting to block networking to snap command, rather than a
        #   complete shutoff. Old code kept until this is confirmed to work.

        # Install snap. Use --classic flag if necessary.
        if [[ $confinement == 'classic' ]]; then
            pkexec "$AS_ROOT" unshare -n snap install "$snaps_dir/$arch/${name}_${rev}.snap" --classic 2>&1 | tee -a "$LOG"
            ret=${PIPESTATUS[0]}
        else
            pkexec "$AS_ROOT" unshare -n snap install "$snaps_dir/$arch/${name}_${rev}.snap" 2>&1 | tee -a "$LOG"
            ret=${PIPESTATUS[0]}
        fi

        # Restore networking.
        #nmcli networking on

        if [[ $ret -gt 0 ]]; then # failed to install
            change=$(snap changes | tail -n2 | head -1 | tr -s ' ' \
                | cut -d' ' -f1)
            # TODO: Do these error grabs work for other locales?
            needs_prereqs=$(snap change "$change" | tail -n4 | head -1 \
                | grep 'prerequisites')
            if [[ $needs_prereqs ]]; then
                # Prerequisites are missing.
                echo -e "error: prerequisite(s) needed; use online updates to fix; skipped.\n$change " | tee -a "$LOG"
                # TODO: There needs to be an error window here for the user.
                continue
            else
                # Some other install error.
                echo -e "error, skipped. " | tee -a "$LOG"
                continue
            fi
        else
            echo -e "installed." | tee -a "$LOG"
        fi
    done

    echo | tee -a "$LOG"
}

window_home() {
    # If source(s) not given in options, ask for them interactively.
    sum="$1"
    snaps_dir="$2"

    if [[ $sum -eq 0 ]]; then

        text="<big><b>$(gettext "wasta [Snap] Manager")</b>
$(gettext "Manage snap packages and snap update settings.")</big>

$(gettext "To <b>Add/Update</b> snap packages, first choose your preferred source(s):
<i>If both are selected, the offline source will be used first to limit downloading.</i>")"

        loc_text="$(gettext "Add/update snaps from wasta [Offline] or local folder.")"
        net_text="$(gettext "Update snaps from the online Snap Store.")"
        add_text="$(gettext "Add/Update...")"
        quit_text="$(gettext "Quit")"
        remove_text="$(gettext "Remove...")"
        settings_text="$(gettext "Settings...")"

        net_check=$(dig +short @208.67.222.222 www.google.com +timeout=1 >/dev/null 2>&1)

        ret=$?
        if [ $ret == 0 ]; then
            #network found, give 2 list choices
            list=( "False" "1" "$(gettext "Offline")" "$loc_text" "False" "2" "$(gettext "Online")" "$net_text" )
        else
            #network not found, only 1 choice
            list=( "False" "1" "$(gettext "Offline")" "$loc_text" )
        fi

        sources=$(zenity --list --checklist "${ZDEFAULTS[@]}" \
            --column='' --column=value --column=Source --column=Description \
            --hide-column=2 "${list[@]}" \
            --ok-label="$add_text" \
            --cancel-label="$quit_text" \
            --extra-button="$remove_text" \
            --extra-button="$settings_text" \
            --text="$text" --height=250 2>/dev/null)
        ec=$?
    fi

    # Proceed to window corresponding to chosen button.
    if [[ $ec -eq 1 ]] && [[ $sources ]]; then
        if [[ $sources == $remove_text ]]; then
            # User clicked [Remove...].
            if [[ -x /snap/bin/snap-store ]]; then
                /snap/bin/snap-store --mode=installed 2>/dev/null
            else
                window_remove_snaps
            fi
        elif [[ $sources == $settings_text ]]; then
            # User clicked [Settings...].
            if [[ -x /usr/bin/snap-settings ]]; then
                /usr/bin/snap-settings
            else
                window_settings
            fi
        fi
    elif [[ $ec -eq 1 ]]; then
        # User clicked [Quit] or the [x].
        exit 0
    elif [[ $ec -eq 0 ]]; then
        # User clicked [Add/Update...]

        # Restart window if no sources selected.
        if [[ ! $sources ]]; then
            window_home "0"
        fi

        # Add 0 ouput for unchecked boxes.
        if [[ "$sources" -eq 1 ]]; then
            sources="$sources|0"
        elif [[ "$sources" -eq 2 ]]; then
            sources="0|$sources"
        fi

        # Evaluate user's response.
        OFFL="${sources%|*}"
        INET="${sources#*|}"
        SUM=$(($INET + $OFFL))

        ask_offline_folder "$OFFL" "$snaps_dir"
        create_log "$SUM" "$SNAPS_DIR"
        window_add_or_update_snaps "$SNAPS_DIR" "$SUM"
    else
        # Unknown error.
        echo "Unhandled error. Exiting." | tee -a "$LOG"
        exit 1
    fi
}

# Show window of snapd settings that are recommended to be modified by the user.
window_settings() {
    # snapd settings:
    #   https://forum.snapcraft.io/t/system-options/87

    # Elevate to root privileges before opening window.
    pkexec "$AS_ROOT" elevate
    if [[ $? -eq 126 ]]; then
        # User cancelled authorization window.
        window_home "0"
    fi

    # Build list of current settings. This list includes:
    #   - handling of metered connections, $m_handling_def
    #   - current connection metered status, $c_metered_def
    #   - snap automatic refresh timer, $r_timer_def
    #   - number of total snap revisions to keep, $r_kept_def

    # Note defaults and suggested values.
    m_handling_def=null
    m_handling_sug=hold
    c_metered_def='unknown'
    c_metered_sug='yes'
    r_timer_def='00:00~24:00/4'
    r_timer_sug='sun5,02:00'
    r_kept_def=3
    r_kept_sug=2

    # Get current settings.
    # ---------------------------------
    # Get metered status of current internet connection.
    inet_device=$(ip route | grep 'default via' | awk '{print $5}')
    inet_connection=''
    if [[ $inet_device ]]; then
        inet_connection=$(nmcli -t -f GENERAL.CONNECTION --mode tabular dev show "$inet_device")
    fi
    if [[ $inet_connection ]]; then
        metered_status=$(
            LANG=C nmcli -f connection.metered connection show "$inet_connection" \
            | tr -s ' ' | cut -d' ' -f2
        )
    else
        metered_status="$(gettext "disconnected")"
    fi

    # Create a pipe to get pkexec output without a subshell. This is done to
    #   avoid multiple authentications for command substitutions that would
    #   otherwise be run in subshells and therefore not "stick" for later
    #   pkexec calls.
    mkfifo /tmp/wfifo
    exec 5<> /tmp/wfifo

    # Set settings variables.
    {
        pkexec "$AS_ROOT" snap get system refresh.metered 2>/dev/null
        echo "@"
     } 1>&5
    read -u5 m_handling
    if [[ $m_handling == '@' ]]; then
        # Command had no output. Pipe is now empty.
        m_handling=null
    else
        # Command output was read into $m_handling, now remove '@' from pipe.
        read -u5 ignored
    fi

    c_metered="$metered_status"

    r_timer=$(snap refresh --time | head -1 | sed -r 's/^timer: (.*)$/\1/')

    # Run command block. Send output to /tmp/wfifo via fd5.
    {
        pkexec "$AS_ROOT" snap get system refresh.retain 2>/dev/null
        echo "@"
    } 1>&5
    # Get output data from /tmp/wfifo.
    read -u5 r_kept
    if [[ $r_kept == '@' ]]; then
        # Command had no output. Pipe is now empty.
        r_kept=3
    else
        # Command output was read into $m_handling, now remove '@' from pipe.
        read -u5 ignored
    fi

    # Initialize list for zenity checklist window.
    settings=()

    # Add $c_metered details to the list if connected.
    desc="$(gettext "Set current connection as metered")"
    if [[ $c_metered == $(gettext "disconnected") ]]; then
        settings+=()
    elif [[ $c_metered == $c_metered_sug ]]; then
        settings+=( "True" "connection.metered" "$desc" "$c_metered" "$c_metered_sug" )
    else
        settings+=( "False" "connection.metered" "$desc" "$c_metered" "$c_metered_sug" )
    fi

    # Add $m_handling details.
    desc="$(gettext "Auto-refresh on metered connections")"
    if [[ $m_handling == $m_handling_sug ]]; then
        settings+=( "True" )
    else
        settings+=( "False" )
    fi
    settings+=( "refresh.metered" "$desc" "$m_handling" "$m_handling_sug" )

    # Add $r_timer details.
    desc="$(gettext "Auto-refresh time window")"
    if [[ $r_timer == $r_timer_sug ]]; then
        settings+=( "True" )
    else
        settings+=( "False" )
    fi
    settings+=( "refresh.timer" "$desc" "$r_timer" "$r_timer_sug" )

    # Add $r_kept details.
    desc="$(gettext "Number of snap revisions kept")"
    if [[ $r_kept == $r_kept_sug ]]; then
        settings+=( "True" )
    else
        settings+=( "False" )
    fi
    settings+=( "refresh.retain" "$desc" "$r_kept" "$r_kept_sug" )

    # Show zenity checklist window.
    text="<big><b>$(gettext "Manage snapd settings.")</b></big>\n
$(gettext "Settings corresponding to suggested values are checked.
Uncheck the box to restore defaults.")"
    override_defaults=$(zenity --list --checklist "${ZDEFAULTS[@]}" \
        --height=350 \
        --column='' --column="$(gettext "Setting")" \
        --column="$(gettext "Description")" \
        --column="$(gettext "Current")" --column="$(gettext "Suggested")" \
        "${settings[@]}" --separator='\n' --cancel-label="$(gettext "Back")" \
        --text="$text" 2>/dev/null
    )
    if [[ $? -eq 1 ]]; then
        # User clicked [Back]; remove temporary pipe and go to $window_home.
        exec 5>&-
        rm /tmp/wfifo
        window_home "0"
    fi

    # Remove temporary pipe.
    exec 5>&-
    rm /tmp/wfifo

    # Apply default settings.
    # ---------------------------------
    echo "Initializing settings..."
    # It's up to NetworkManager to determine whether a connection is metered.
    #   However, the user can also explicity set a connection as metered.
    echo "Set connection.metered as default [$c_metered_def]."
    if [[ $inet_connection ]]; then
        LANG=C nmcli connection modify "$inet_connection" connection.metered "$c_metered_def"
    fi

    # Whether or not snapd auto-refreshes snaps on any metered connection.
    echo "Set refresh.metered as default [$m_handling_def]."
    pkexec "$AS_ROOT" snap set system refresh.metered="$m_handling_def"

    # Affect the timing and frequency of snap refreshes.
    echo "Set refresh.timer as default [$r_timer_def]."
    pkexec "$AS_ROOT" snap set system refresh.timer="$r_timer_def"

    # Choose number of snap revisions to keep.
    echo "Set refresh.retain as default [$r_kept_def]."
    pkexec "$AS_ROOT" snap set system refresh.retain="$r_kept_def"

    # Apply overridden settings.
    # ---------------------------------
    setting_names=( "connection.metered" "refresh.metered" "refresh.timer" "refresh.retain" )
    for s in ${setting_names[@]}; do
        for o in ${override_defaults[@]}; do
            if [[ $s == 'connection.metered' ]]; then
                if [[ $s == $o ]]; then
                    echo "Set $s to $c_metered_sug"
                    # Set current connection to $c_metered_sug.
                    echo "Setting $s to $c_metered_sug..."
                    LANG=C nmcli connection modify "$inet_connection" connection.metered "$c_metered_sug"
                else
                    continue
                fi
            elif [[ $s == 'refresh.metered' ]]; then
                if [[ $s == $o ]]; then
                    echo "Set $s to $m_handling_sug"
                    # Set refresh.metered to $m_handling_sug.
                    echo "Setting $s to $m_handling_sug..."
                    pkexec "$AS_ROOT" snap set system refresh.metered="$m_handling_sug"
                else
                    continue
                fi
            elif [[ $s == 'refresh.timer' ]]; then
                if [[ $s == $o ]]; then
                    echo "Set $s to $r_timer_sug"
                    # Set refresh.timer to $r_timer_sug.
                    echo "Setting $s to $r_timer_sug..."
                    pkexec "$AS_ROOT" snap set system refresh.timer="$r_timer_sug"
                else
                    continue
                fi
            elif [[ $s == 'refresh.retain' ]]; then
                if [[ $s == $o ]]; then
                    echo "Set $s to $r_kept_sug"
                    # Keep $r_kept_sug number of snap revisions.
                    echo "Setting $s to $r_kept_sug..."
                    pkexec "$AS_ROOT" snap set system refresh.retain="$r_kept_sug"
                else
                    continue
                fi
            else
                continue
            fi
        done
    done

    # Refresh the window to show changes.
    window_settings
}

# Show window of available snaps to update or install.
window_add_or_update_snaps() {
    # This function takes $SNAPS_DIR and $SUM as arguments.
    #   It lets the user install or update snaps both offline and online.
    snaps_dir="$1"
    install_mode="$2" # 1 = online-only, 2 = offline-only, 3 = offline then online

    # Prepare to add/update snaps from offline source if chosen.
    if [[ ! $install_mode -eq 2 ]]; then
        echo "=== Add/Update Snaps window ===" >> "$LOG"
        list_installed_snaps                                     # -> $snaps_installed
        list_available_snaps "$snaps_dir"                        # -> $snaps_available
        list_updatable_snaps "snaps_installed" "snaps_available" # -> $snaps_updatable
        waiting_text="$(gettext "Waiting for authorization...")"

        if [[ $wasta_offline_launch ]]; then
            # Update offline snaps; don't show other available snaps.
            install_snaps "snaps_available" "snaps_updatable" "$snaps_dir" \
                | zenity "${ZDEFAULTS[@]}" "${ZPROGDEFS[@]}" --no-cancel \
                    --text="$waiting_text" 2>/dev/null
        else
            # Show updatable and installable snaps.
            show_offline_updates "snaps_installed" "snaps_available" "snaps_updatable" # -> $selected_snaps

            # Test if $selected_snaps list is empty.
            if [[ ! ${selected_snaps[@]} && $install_mode -eq 1 ]]; then
                # Empty update/install list. Return to main window.
                window_home
            fi

            # Install offline snaps; show progress window.
            install_snaps "snaps_available" "selected_snaps" "$snaps_dir" \
                | zenity "${ZDEFAULTS[@]}" "${ZPROGDEFS[@]}" --no-cancel \
                    --text="$waiting_text" 2>/dev/null
        fi
    fi

    # Refresh snaps if $INET=2; show progress window.
    if [[ $install_mode -gt 1 ]]; then
        #last=$(snap change --last=refresh)
        textA="$(gettext "Updating snaps from the Snap store.")"
        textB="$(gettext "\n\tThis might take several minutes on a slow connection.\n\n")"
        echo "$textA" | tee -a "$LOG"
        # TODO: Need some kind of indication of actual progress?
        # TODO: "Cancel" in the following zenity window doesn't work (subprocess)
        pkexec "$AS_ROOT" snap refresh | tee -a "$LOG" &
        pk_pid=$!

        tmp=$(mktemp)
        (
            # Wait for snap refresh background process to start
            ct=0
            while [[ ! $(pgrep -a snap | grep -v "wasta-snap-manager" \
                | grep "snap refresh" | cut -d' ' -f1) ]]; do
                sleep 1
                ((ct+=1))
                [[ $ct == 4 ]] && break  #maximum 4s wait to start snap refresh
            done

            # Show undefined progress window while refreshing snaps.
            ref_pid=$(pgrep -a snap | grep -v "wasta-snap-manager" \
                | grep "snap refresh" | cut -d' ' -f1)
            echo "$ref_pid" > "$tmp"
            while [[ $(ps --no-headers -p $ref_pid) ]]; do
                if [[ $ct -lt 60 ]]; then
                    elap=$(date -ud "@$ct" +':%S')
                elif [[ $ct -lt 3600 ]]; then
                    elap=$(date -ud "@$ct" +'%M:%S')
                else
                    elap=$(date -ud "@$ct" +'%H:%M:%S')
                fi
                echo "#$textA$textB $elap"
                sleep 1
                ((ct+=1))
            done
        ) | zenity "${ZDEFAULTS[@]}" "${ZPROGDEFS[@]}" 2>/dev/null
        ret=$?

        if [[ $ret -gt 0 ]]; then
            # Some error or user cancelled.
            ref_pid=$(cat "$tmp")
            pkexec "$AS_ROOT" kill $pk_pid $ref_pid
        fi
        rm "$tmp"
    fi

    # Exit now if launched from wasta-offline.
    if [[ $wasta_offline_launch ]]; then
        # Exit wasta-snap-manager to continue wasta-offline.
        echo "Snap updates complete. Continuing with wasta-offline." | tee -a "$LOG"
        exit 0
    fi

    # Return to Remove Snaps Window if doing online updates only.
    if [[ $install_mode -eq 2 ]]; then
        window_remove_snaps
    else
        # Return to Home Window.
        window_home
    fi
}

# Show window of installed snaps & allow for their removal.
window_remove_snaps() {
    # This function takes no arguments. It lets the user uncheck installed
    #   snaps in order to uninstall them. It can also be used to simply show
    #   a list of installed snaps.
    if [[ ! $LOG ]]; then
        create_log
    fi
    echo "=== Remove Snaps window ===" >> "$LOG"
    list_installed_snaps # -> $snaps_installed
    show_installed_snaps "snaps_installed" # -> $snaps_to_remove

    # Test if snaps_to_remove list is empty.
    if [[ ! ${snaps_to_remove[@]} ]]; then
        # Empty removal list. Return to main window.
        window_home
    fi

    # Remove snaps; show progress window.
    remove_snaps "snaps_to_remove" \
        | zenity "${ZDEFAULTS[@]}" "${ZPROGDEFS[@]}" --no-cancel \
            --text="$(gettext "Waiting for authorization...")" 2>/dev/null

    # Return to Remove Snaps Window.
    window_remove_snaps
}


# ---------------------------------------------------------------------------
# Main processing.
# ---------------------------------------------------------------------------

# If folder argument is passed, go directly to updating snaps.
#   E.g., if launched from wasta-offline.
if [[ $OFFL -eq 1 ]]; then
    wasta_offline_launch=1
    create_log "$SUM" "$SNAPS_DIR"
    window_add_or_update_snaps "$SNAPS_DIR" "$SUM"
else
    # Launch main window.
    wasta_offline_launch=''
    window_home "$SUM" "$SNAPS_DIR"
fi

exit 0
