#!/bin/bash

# ===========================================================================
# Purpose:
#   - Provide for installing, updating, and removing snap packages without
#       an internet connection.
# Goals:
#   - Accept an argument indicating a folder where snaps and asserts are kept.
#   - Guide the user to select such a folder when there is no argument.
#   - Present a list of snaps to install or update, allowing the user to select
#       from among them.
#   - Ensure that the core snap(s) is/are installed/updated first.
#   - Ensure that prerequisite snaps are installed.
#   - Ensure that snaps will be able to receive automatic updates, as if they
#       were installed directly from the snap store.
#   - Allow user to manage snapd settings, such as refresh timer, metered
#       connections, number of revisions kept.
# ===========================================================================

# TODO: delete after testing
> "/media/test/WASTA-OL/wasta-offline/log/wasta-snap-manager/cat.txt"

# ---------------------------------------------------------------------------
# Set global variables.
# ---------------------------------------------------------------------------
USAGE_TEXT="usage: $0 [-h] | [-i] [-s /path/to/dir] [snap name(s)...]"
HELP_TEXT="$USAGE_TEXT

This app updates snap apps. The updates can come from the internet, a directory,
or both. If no options or args are passed, update information will be requested
interactively. If no snap names are given, then updates are attempted for all
installed snaps.

    -h                  Show this help text.
    -i                  Search online for updates.
    -s  /path/to/dir    Look for downloaded updates in /path/to/dir.
    snap1 snap2 ...     Space-separated list of snaps to install or update.

"

# Empty intial value for $SNAPS_DIR.
SNAPS_DIR=''

# Initial value for online source.
INET=0
OFFL=0


# ---------------------------------------------------------------------------
# Parse options passed.
# ---------------------------------------------------------------------------
while getopts ":his:" opt; do
    case $opt in
        h) # help requested
            echo "$HELP_TEXT"
            exit 0
            ;;
        i) # check internet for updates
            INET=2
            ;;
        s) # source directory option passed
            SNAPS_DIR=$(realpath "$OPTARG")
            OFFL=1
            ;;
        /?) # invalid option
            echo "$USAGE_TEXT"
            exit 1
    esac
done
shift $((OPTIND-1))

# System info
LOG_DATE=$(date +%F-%H-%M)
HOST=$(uname -n)

# PolicyKit root app path.
AS_ROOT=/usr/bin/wasta-snap-manager-root

# Starting value for determining update sources.
SUM=$(($INET + $OFFL))

# Zenity defaults
ZTITLE="Wasta [Snap] Manager"
ZHEIGHT=450
ZWIDTH=650
ZICON=/usr/share/icons/hicolor/512x512/apps/wasta-offline.png
ZICNM=wasta-offline
ZDEFAULTS=(
    --title="$ZTITLE" --height="$ZHEIGHT" --width="$ZWIDTH" \
    --window-icon="$ZICON" #--icon-name="$ZICNM"
)
ZPROGDEFS=(
    --progress --pulsate --height=175 --auto-close
)

# Core snaps assumed.
CORES=( core core18 )


# ---------------------------------------------------------------------------
# Define functions.
# ---------------------------------------------------------------------------
ask_offline_folder() {
    # Ask user for offline folder location if not passed as argument.
    offl="$1"
    snaps_dir="$2"

    if [[ ! $snaps_dir ]] && [[ $offl -eq 1 ]]; then
        # Determine potential $START_FOLDER.
        text="\n\n\nSearching system for wasta [Offline] folder..."
        # Convoluted yet functional zenity subprocess inspired by this article:
        #   http://wiki.bash-hackers.org/zenity_--progress
        wo_list=$(
            find /media /mnt /home/"$USER" -not -path '*/.*' -maxdepth 3 \
                -name 'wasta-offline' -type d 2>/dev/null | tee >(
                    zenity --text="$text" "${ZDEFAULTS[@]}" "${ZPROGDEFS[@]}" \
                        --auto-kill --no-cancel 2>/dev/null
                    )
        )
        if [[ -z $wo_list ]]; then
            START_FOLDER=/home/"$USER"/
        else
            for d in ${wo_list[@]}; do
                loc_cache=$(find "$d" -maxdepth 1 -name 'local-cache' -type d 2>/dev/null)
                if [[ $loc_cache =~ ^/media/.*$ ]]; then
                    # Automatically accept 'wasta-offline' folder in /media/...
                    START_FOLDER="$d"
                    # Title for upcoming file chooser dialog.
                    title="Confirm the wasta-offline folder or choose another one"
                    break
                elif [[ $loc_cache ]]; then
                    # Accept other 'wasta-offlne' folder, but let one in /media/... overrule it.
                    #   In case there are more than two qualifiers, the last one found wins.
                    START_FOLDER="$d"
                    title="Confirm the wasta-offline folder or choose another one"
                else
                    # No "true" wasta-offline folder found.
                    START_FOLDER=/home/"$USER"/
                    title="Choose the offline snaps folder"
                fi
            done
        fi
        SNAPS_DIR=$(
            zenity --file-selection --directory --title="$title" \
                --filename="$START_FOLDER" 2>/dev/null
        )
        if [[ $? -ne 0 ]]; then
            # User clicked "Cancel". Exit.
            window_home "0"
        fi
    fi
}

create_log() {
    # Set log location.
    #   Needs to happen before $SNAPS_DIR adjustment below.
    #   Can't guarantee a $SNAPS_DIR if source is online only.
    sum="$1"
    SNAPS_DIR="$2"

    if [[ $SNAPS_DIR ]]; then
        LOG_DIR="$SNAPS_DIR/log/wasta-snap-manager"
    else
        LOG_DIR=/home/$USER/.log/wasta-snap-manager
    fi
    mkdir -p "$LOG_DIR"
    LOG="$LOG_DIR/$LOG_DATE-$HOST.log"

    # Need to be able to handle 2 types of SNAPS_DIRs:
    #   1. "wasta-offline" folder -> Set SNAPS_DIR as wasta-offline/local-cache/snaps.
    #   2. any other folder passed -> Set SNAPS_DIR as passed argument.
    if [[ $SNAPS_DIR =~ ^.*wasta-offline$ ]]; then
        SNAPS_DIR="$SNAPS_DIR"/local-cache/snaps
        # Make sure SNAPS_DIR exists.
        mkdir -p "$SNAPS_DIR"
    fi

    # Initial log entry
    echo "-------------------------------------------------------" | tee -a "$LOG"
    echo "*** Installing/updating snaps                          " | tee -a "$LOG"
    echo "-------------------------------------------------------" | tee -a "$LOG"

    # Note defined update source(s).
    echo "Update source(s):"                    | tee -a "$LOG"
    case $sum in
        1) # offline updates only
            echo "$SNAPS_DIR"                   | tee -a "$LOG"
            ;;
        2) # online updates only
            echo "Snap store."                  | tee -a "$LOG"
            ;;
        3) # offline and online updates
            echo "$SNAPS_DIR, then Snap store." | tee -a "$LOG"
    esac
    echo | tee -a "$LOG"
}

list_installed_snaps() {
    # Get list of snaps currently installed. Create global associative array
    #   of installed snaps and their revision numbers: $snaps_installed

    # Delete previous $snaps_installed.
    unset snaps_installed[@]

    # Recreate updated $snaps_installed.
    installed_list=$(snap list | grep -v Name)
    if [[ -w $LOG ]]; then
        echo -e "Installed snaps:\n$installed_list\n" >> "$LOG"
    fi

    # Add these snap names to $snaps_installed dictionary.
    declare -Ag snaps_installed
    if [[ ! $installed_list == '' ]]; then
        while read -r line; do
            name=$(echo "$line" | tr -s ' ' | cut -d' ' -f1)
            rev=$(echo "$line" | tr -s ' ' | cut -d' ' -f3)
            #fileloc=$SNAPS/${snap}_${rev}.snap
            #size=$(stat --printf="%s" "$fileloc")
            snaps_installed["$name"]="$rev"
        done <<< "$installed_list"
    fi
}

list_available_snaps() {
    snaps_dir="$1"

    # Get offline snaps in $SNAPS_DIR.
    available_list=$(find "$snaps_dir"/ -name '*.snap')

    # Build associative array of available snaps and revisions in SNAPS_DIR.
    #   The revision numbers are space-delimited; e.g. ("[skype]"="54 57 ").
    declare -A snaps_avail_all
    for i in ${available_list[@]}; do
        name_rev=${i##*/}
        name_rev=${name_rev%.snap}
        rev=${name_rev##*_}
        name=${name_rev%_*}
        snaps_avail_all["$name"]+="$rev "
    done

    # Sort revisions listed for each snap, choose highest one.
    declare -Ag snaps_available
    for name in ${!snaps_avail_all[@]}; do
        top=$(
            for r in ${snaps_avail_all[$name]}; do
                echo $r
            done | sort -nr | head -1
        )
        snaps_available["$name"]="$top"
    done
}

list_updatable_snaps() {
    declare -n inst="$1"
    declare -n avail="$2"

    # Find any $snaps_available newer than $snaps_installed.
    declare -Ag snaps_updatable
    for name in ${!inst[@]}; do
        inst_rev="${inst[$name]}"
        avail_rev="${avail[$name]}"
        if [[ $avail_rev -gt $inst_rev ]]; then
            snaps_updatable[$name]="$avail_rev"
        fi
    done
}

list_prerequisites() {
    # Find and list the given snap's prerequisites.
    snap_file="$1"
    unset snap_prereqs[@]
    declare -Ag snap_prereqs
    tmpd=$(mktemp -d)
    pkexec "$AS_ROOT" mount "${SNAPS_DIR}/${snap_file}" "$tmpd"

    yaml="${tmpd}/meta/snap.yaml"
    expr='s/.*:\s(.*)/\1/'
    base=$(cat "$yaml" | grep 'base:' | sed -r "$expr") # 0 or 1 line
    confinement=$(cat "$yaml" | grep 'confinement:' | sed -r "$expr") # 1 line
    prereqs=$(cat "$yaml" | grep 'default-provider:' | sed -r "$expr") # 0 to multiple lines

    # Add "default-provider" prereqs to array.
    if [[ $prereqs ]]; then
        for p in $prereqs; do
            snap_prereqs[$p]=''
        done
    fi

    pkexec "$AS_ROOT" umount "$tmpd"
    rm -r "$tmpd"
}

show_installed_snaps() {
    declare -n installed="$1"
    # Remove core snaps from list to avoid accidentally uninstalling them.
    # TODO: Obviously this will need to be revised for any future core snaps,
    #   but it seems unwise to try to match snaps beginning with 'core';
    #   e.g., corebird.
    for c in ${CORES[@]}; do
        unset installed[$c]
    done

    # Build list for displaying installed snaps.
    list_installed_unsorted=( ${!installed[@]} )
    installed_sorted=( $(printf '%s\n' "${list_installed_unsorted[@]}" | sort) )

    installed_snaps=()
    for name in "${installed_sorted[@]}"; do
        rev="${installed[$name]}"
        installed_snaps+=( "True" "$name" "$rev" )
    done

    # Show zenity --checklist for user to choose updates/installs.
    text="<big><b>\
Installed snap packages.</b></big>\n
To uninstall snap packages, deselect them and click \"OK\"\n"
    kept_snaps=$(zenity --list --checklist "${ZDEFAULTS[@]}" \
        --title="Wasta [Snap] Manager" \
        --column='' --column="Snap" --column="Revision" \
        "${installed_snaps[@]}" --separator='\n' \
        --text="$text" --cancel-label="Back" 2>/dev/null
    )
    if [[ $? -eq 1 ]]; then
        # User clicked [Back].
        window_home "0"
    fi

    # Compare $installed_snaps with $kept_snaps to produce $snaps_to_remove
    snaps_to_remove=$(
        echo "${installed_sorted[@]}" "${kept_snaps[@]}" \
        | tr ' ' '\n' | sort | uniq -u
    )
}

remove_snaps() {
    declare -n to_remove="$1"

    # Elevate to root privileges before removing.
    pkexec "$AS_ROOT" elevate
    if [[ $? -eq 126 ]]; then
        # Removal cancelled.
        exit 1
    fi

    # Remove snaps.
    for name in ${to_remove[@]}; do
        # Output to progress dialog.
        echo "#Removing snaps.\n\n\nRemoving $name..."
        echo -en "Removing $name... " | tee -a "$LOG"

        pkexec "$AS_ROOT" snap remove "$name"
        ret=$?
        if [[ $ret -eq 126 ]]; then
            # Snap removal cancelled.
            echo -e "cancelled." | tee -a "$LOG"
            exit 1
        elif [[ $ret -gt 0 ]]; then
            echo "ret: $ret" | tee -a "$LOG"
            # Some other error.
            echo -e "error, skipped." | tee -a "$LOG"
            continue
        else
            # Snap removed successfully.
            echo -e "removed." | tee -a "$LOG"
        fi
    done

    echo | tee -a "$LOG"
}

show_offline_updates() {
    declare -n installed="$1"
    declare -n available="$2"
    declare -n updatable="$3"

    # Build list for displaying updatable and installable snaps.
    avail_unsorted=( ${!available[@]} )
    avail_sorted=( $(printf '%s\n' "${avail_unsorted[@]}" | sort) )

    available_snaps=()
    for name in "${avail_sorted[@]}"; do
        inst_rev="${installed[$name]}"
        avail_rev="${available[$name]}"
        if [[ ${installed[$name]} ]]; then
            if [[ ${updatable[$name]} ]]; then
                available_snaps+=( "True" "$name" "$inst_rev" "$avail_rev" )
            fi
        else
            available_snaps+=( "False" "$name" "-" "$avail_rev" )
        fi
    done

    # Show zenity --checklist for user to choose updates/installs.
    if [[ $available_snaps ]]; then
        text="<big><b>\
These offline snap packages are available for this computer.</b></big>
Available updates are already selected. New packages can be installed by selecting them as well."
        selected_snaps=$(zenity --list --checklist "${ZDEFAULTS[@]}" \
            --title="Wasta [Snap] Manager" \
            --ok-label="Add/Update" --cancel-label="Back" \
            --column='' --column="Snap" --column="Installed Revision" --column="Available Revision" \
            "${available_snaps[@]}" --separator='\n' \
            --text="$text" 2>/dev/null
        )
        ec=$?
        if [[ $ec -eq 1 ]]; then
            # User clicked Cancel. Go to Home Window.
            window_home "0"
        fi
    else
        text="<big><b>No updated snaps are available.</b></big>"
        zenity --info "${ZDEFAULTS[@]}" --width=350 --height=150 \
                --text="$text" 2>/dev/null
        window_home "0"
    fi
}

install_cores() {
    # Install/update core snaps.
    for name in ${CORES[@]}; do
        # Test if core snap is available offline.
        if [[ ${available[$name]} ]]; then
            # Get revision number of available core snap.
            rev_avail="${available[$name]}"
            # Test if core snap is already installed.
            snap list "$name" >/dev/null 2>&1
            ret=$?
            if [[ $ret -eq 0 ]]; then
                # Core snap installed. Get revision number.
                rev_exist=$(snap list $name | grep "$name" | tr -s ' ' | cut -d' ' -f3)
                if [[ $rev_exist -ge $rev_avail ]]; then
                    # Most-recent offline revision already installed.
                    continue
                fi
            fi

            # Output to progress dialog and to $LOG.
            echo "#Installing/updating snaps from:\n\t$snaps_dir\n\nInstalling $name..."
            echo -en "Installing $name from offline source... " | tee -a "$LOG"

            # Acknowledge assertion and install snap.
            pkexec "$AS_ROOT" snap ack "$snaps_dir/${name}_${rev_avail}.assert"
            pkexec "$AS_ROOT" snap install "$snaps_dir/${name}_${rev_avail}.snap" 2>/dev/null
            if [[ $? -gt 0 ]]; then
                # Some install error.
                change=$(snap changes | tail -n2 | head -1 | tr -s ' ' \
                    | cut -d' ' -f1)

                # Output to progress dialog and to $LOG.
                echo "#Error installing $name; installation skipped"
                echo -e "error, skipped.\n$change " | tee -a "$LOG"
                continue
            else
                echo -e "installed." | tee -a "$LOG"
            fi
        fi
    done
}

install_prerequisites() {
    echo "Installing prereqs" | tee -a "$LOG"
    declare -n prereqs="$1"
    #declare -n available="$1"
    #declare -n prereqs="$2"
    #snaps_dir="$3"

    # Elevate to root privileges before installing.
    if [[ ! ${!prereqs[@]} ]]; then
        # No installs or updates selected.
        echo "No prerequisites to install." | tee -a "$LOG"
        return 0
    fi
    pkexec "$AS_ROOT" elevate
    if [[ $? -eq 126 ]]; then
        # Installation cancelled.
        return 1
    fi

    for p in ${!prereqs[@]}; do
        echo "prereq name: $p" >> "${LOG_DIR}/cat.txt"
        r="${available[$p]}"
        # Output to progress dialog and to $LOG.
        echo "#Installing/updating snaps from:\n\t$snaps_dir\n\nInstalling $p..."
        echo -en "Installing $p from offline source... " | tee -a "$LOG"
        pkexec "$AS_ROOT" snap ack "$snaps_dir/${p}_${r}.assert" #2>"$LOG"
        nmcli networking off
        pkexec "$AS_ROOT" snap install "$snaps_dir/${p}_${r}.snap" #2>"$LOG"
        ret=$?
        nmcli networking on
        if [[ $ret -gt 0 ]]; then # failed to install
            # Some other install error.
            echo -e "error, skipped. " | tee -a "$LOG"
            continue
        else
            echo -e "installed." | tee -a "$LOG"
        fi
    done
}

install_snaps() {
    # This function is only used to install offline snaps.
    declare -n available="$1"
    declare -n to_install="$2"
    snaps_dir="$3"

    # Elevate to root privileges before installing.
    if [[ ! ${to_install[@]} ]]; then
        # No installs or updates selected.
        echo "Nothing to install or update." | tee -a "$LOG"
        return 0
    fi

    pkexec "$AS_ROOT" elevate
    if [[ $? -eq 126 ]]; then
        # Installation cancelled.
        echo "Installation cancelled!" | tee -a "$LOG"
        # Ensure that networking is back on.
        #nmcli networking on
        return 1
    fi

    # Install/update core snaps.
    install_cores

    # Install/update selected snaps.
    for name in ${to_install[@]}; do

        rev="${available[$name]}"

        # Output to progress dialog and to $LOG.
        echo "#Installing/updating snaps from:\n\t$snaps_dir\n\nInstalling $name..."
        echo -en "Installing $name from offline source... " | tee -a "$LOG"

        # TODO: list and install prerequisites.
        list_prerequisites "${name}_${rev}.snap"

        # Install prereqs for current snap.
        if [[ ! ${!snap_prereqs[@]} == '' ]]; then
            install_prerequisites "snap_prereqs"
        fi

        # Acknowledge assertion.
        pkexec "$AS_ROOT" snap ack "$snaps_dir/${name}_${rev}.assert" #2>"$LOG"

        # Force networking to be offline to avoid downloading snap prereqs.
        # TODO: Ideally I would just block networking to wasta-snap-manager somehow, rather than a complete shutoff.
        #   - Better solution: temporarily convince snap that there is no network, but how?
        nmcli networking off

        # Install snap. Use --classic flag if necessary.
        if [[ $confinement == 'classic' ]]; then
            pkexec "$AS_ROOT" snap install "$snaps_dir/${name}_${rev}.snap" --classic 2>/dev/null
            ret=$?
        else
            pkexec "$AS_ROOT" snap install "$snaps_dir/${name}_${rev}.snap" 2>/dev/null
            ret=$?
        fi

        # Restore networking.
        nmcli networking on

        if [[ $ret -gt 0 ]]; then # failed to install
            change=$(snap changes | tail -n2 | head -1 | tr -s ' ' \
                | cut -d' ' -f1)
            # TODO: Do these error grabs work for other locales?
            needs_prereqs=$(snap change "$change" | tail -n4 | head -1 \
                | grep 'prerequisites')
            if [[ $needs_prereqs ]]; then
                # Prerequisites are missing.
                echo -e "error: prerequisite(s) needed; use online updates to fix; skipped.\n$change " | tee -a "$LOG"
                # TODO: There needs to be an error window here for the user.
                continue
            else
                # Some other install error.
                echo -e "error, skipped. " | tee -a "$LOG"
                continue
            fi
        else
            echo -e "installed." | tee -a "$LOG"
        fi
    done

    echo | tee -a "$LOG"
}

window_home() {
    # If source(s) not given in options, ask for them interactively.
    sum="$1"
    snaps_dir="$2"

    if [[ $sum -eq 0 ]]; then

        text="<big><b>wasta [Snap] Manager</b>
Manage snap packages and snap update settings.</big>

To <b>Add/Update</b> snap packages, first choose your preferred source(s):
<i>If both are selected, the offline source will be used first to limit downloading.</i>"

        loc_text="Add/update snaps from wasta [Offline] or local folder."
        net_text="Update snaps from the online Snap Store."
        list=( "False" "1" "Offline" "$loc_text" "False" "2" "Online" "$net_text" )
        sources=$(zenity --list --checklist "${ZDEFAULTS[@]}" \
            --column='' --column=value --column=Source --column=Description \
            --hide-column=2 "${list[@]}" \
            --ok-label="Add/Update..." --cancel-label="Quit" \
            --extra-button="Remove..." --extra-button="Settings..." \
            --text="$text" --height=200 2>/dev/null)
        ec=$?
    fi

    # Proceed to window corresponding to chosen button.
    if [[ $ec -eq 1 ]] && [[ $sources ]]; then
        if [[ $sources == 'Remove...' ]]; then
            # User clicked [Remove...].
            window_remove_snaps
        elif [[ $sources == 'Settings...' ]]; then
            # User clicked [Settings...].
            window_settings
        fi
    elif [[ $ec -eq 1 ]]; then
        # User clicked [Quit] or the [x].
        exit 0
    elif [[ $ec -eq 0 ]]; then
        # User clicked [Add/Update...]

        # Restart window if no sources selected.
        if [[ ! $sources ]]; then
            window_home "0"
        fi

        # Add 0 ouput for unchecked boxes.
        if [[ "$sources" -eq 1 ]]; then
            sources="$sources|0"
        elif [[ "$sources" -eq 2 ]]; then
            sources="0|$sources"
        fi

        # Evaluate user's response.
        OFFL="${sources%|*}"
        INET="${sources#*|}"
        SUM=$(($INET + $OFFL))

        ask_offline_folder "$OFFL" "$snaps_dir"
        create_log "$SUM" "$SNAPS_DIR"
        window_add_or_update_snaps "$SNAPS_DIR" "$SUM"
    else
        # Unknown error.
        echo "Unhandled error. Exiting." | tee -a "$LOG"
        exit 1
    fi
}

# Show window of snapd settings that are recommended to be modified by the user.
window_settings() {
    # snapd settings:
    #   https://forum.snapcraft.io/t/system-options/87

    # Elevate to root privileges before opening window.
    pkexec "$AS_ROOT" elevate
    if [[ $? -eq 126 ]]; then
        # User cancelled authorization window.
        window_home "0"
    fi

    # Build list of current settings. This list includes:
    #   - handling of metered connections, $m_handling_def
    #   - current connection metered status, $c_metered_def
    #   - snap automatic refresh timer, $r_timer_def
    #   - number of total snap revisions to keep, $r_kept_def

    # Note defaults and suggested values.
    m_handling_def=null
    m_handling_sug=hold
    c_metered_def='unknown'
    c_metered_sug='yes'
    r_timer_def='00:00~24:00/4'
    r_timer_sug='sun5,02:00'
    r_kept_def=3
    r_kept_sug=2

    # Get current settings.
    pat='s/.*dev\s([0-9a-zA-Z]*).*/\1/'
    all_inet_devices=$(
        ip addr show | grep -Eo '[a-z0-9]{6,}:' | grep -Eo '[a-z0-9]{6,}'
    )

    inet_connection=$(
        for d in ${all_inet_devices[@]}; do
            c=$(nmcli -t -f GENERAL.CONNECTION --mode tabular dev show "$d")
            [[ $c ]] && echo "$c"
        done
    )

    if [[ $inet_connection ]]; then
        metered_status=$(
            nmcli -f connection.metered connection show "$inet_connection" \
            | tr -s ' ' | cut -d' ' -f2
        )
    else
        metered_status='disconnected'
    fi

    # Create a pipe to get pkexec output without a subshell. This is done to
    #   avoid multiple authentications for command substitutions that would
    #   otherwise be run in subshells and therefore not "stick" for later
    #   pkexec calls.
    mkfifo /tmp/wfifo
    exec 5<> /tmp/wfifo

    # Set settings variables.
    {
        pkexec "$AS_ROOT" snap get system refresh.metered 2>/dev/null
        echo "@"
     } 1>&5
    read -u5 m_handling
    if [[ $m_handling == '@' ]]; then
        # Command had no output. Pipe is now empty.
        m_handling=null
    else
        # Command output was read into $m_handling, now remove '@' from pipe.
        read -u5 ignored
    fi

    c_metered="$metered_status"

    r_timer=$(snap refresh --time | head -1 | sed -r 's/^timer: (.*)$/\1/')

    # Run command block. Send output to /tmp/wfifo via fd5.
    {
        pkexec "$AS_ROOT" snap get system refresh.retain 2>/dev/null
        echo "@"
    } 1>&5
    # Get output data from /tmp/wfifo.
    read -u5 r_kept
    if [[ $r_kept == '@' ]]; then
        # Command had no output. Pipe is now empty.
        r_kept=3
    else
        # Command output was read into $m_handling, now remove '@' from pipe.
        read -u5 ignored
    fi

    # Initialize list for zenity checklist window.
    settings=()

    # Add $c_metered details to the list if connected.
    desc="Set current connection as metered"
    if [[ $c_metered == 'disconnected' ]]; then
        settings+=()
    elif [[ $c_metered == $c_metered_sug ]]; then
        settings+=( "True" "connection.metered" "$desc" "$c_metered" "$c_metered_sug" )
    else
        settings+=( "False" "connection.metered" "$desc" "$c_metered" "$c_metered_sug" )
    fi

    # Add $m_handling details.
    desc="Auto-refresh on metered connections"
    if [[ $m_handling == $m_handling_sug ]]; then
        settings+=( "True" )
    else
        settings+=( "False" )
    fi
    settings+=( "refresh.metered" "$desc" "$m_handling" "$m_handling_sug" )

    # Add $r_timer details.
    desc="Auto-refresh time window"
    if [[ $r_timer == $r_timer_sug ]]; then
        settings+=( "True" )
    else
        settings+=( "False" )
    fi
    settings+=( "refresh.timer" "$desc" "$r_timer" "$r_timer_sug" )

    # Add $r_kept details.
    desc="Number of snap revisions kept"
    if [[ $r_kept == $r_kept_sug ]]; then
        settings+=( "True" )
    else
        settings+=( "False" )
    fi
    settings+=( "refresh.retain" "$desc" "$r_kept" "$r_kept_sug" )

    # Show zenity checklist window.
    text="<big><b>Manage snapd settings.</b></big>\n
Settings corresponding to suggested values are checked.
Uncheck the box to restore defaults."
    override_defaults=$(zenity --list --checklist "${ZDEFAULTS[@]}" \
        --height=350 --title="Wasta [Snap] Manager" \
        --column='' --column="Setting" --column="Description" \
        --column="Current" --column="Suggested" \
        "${settings[@]}" --separator='\n' --cancel-label="Back" \
        --text="$text" 2>/dev/null
    )
    if [[ $? -eq 1 ]]; then
        # User clicked [Back]; remove temporary pipe and go to $window_home.
        exec 5>&-
        rm /tmp/wfifo
        window_home "0"
    fi

    # Remove temporary pipe.
    exec 5>&-
    rm /tmp/wfifo

    # Apply default settings.
    # ---------------------------------
    echo "Initializing settings..."
    # It's up to NetworkManager to determine whether a connection is metered.
    #   However, the user can also explicity set a connection as metered.
    echo "Set connection.metered as default [$c_metered_def]."
    if [[ $inet_connection ]]; then
        nmcli connection modify "$inet_connection" connection.metered "$c_metered_def"
    fi

    # Whether or not snapd auto-refreshes snaps on any metered connection.
    echo "Set refresh.metered as default [$m_handling_def]."
    pkexec "$AS_ROOT" snap set system refresh.metered="$m_handling_def"

    # Affect the timing and frequency of snap refreshes.
    echo "Set refresh.timer as default [$r_timer_def]."
    pkexec "$AS_ROOT" snap set system refresh.timer="$r_timer_def"

    # Choose number of snap revisions to keep.
    echo "Set refresh.retain as default [$r_kept_def]."
    pkexec "$AS_ROOT" snap set system refresh.retain="$r_kept_def"

    # Apply overridden settings.
    # ---------------------------------
    setting_names=( "connection.metered" "refresh.metered" "refresh.timer" "refresh.retain" )
    for s in ${setting_names[@]}; do
        for o in ${override_defaults[@]}; do
            if [[ $s == 'connection.metered' ]]; then
                if [[ $s == $o ]]; then
                    echo "Set $s to $c_metered_sug"
                    # Set current connection to $c_metered_sug.
                    echo "Setting $s to $c_metered_sug..."
                    nmcli connection modify "$inet_connection" connection.metered "$c_metered_sug"
                else
                    continue
                fi
            elif [[ $s == 'refresh.metered' ]]; then
                if [[ $s == $o ]]; then
                    echo "Set $s to $m_handling_sug"
                    # Set refresh.metered to $m_handling_sug.
                    echo "Setting $s to $m_handling_sug..."
                    pkexec "$AS_ROOT" snap set system refresh.metered="$m_handling_sug"
                else
                    continue
                fi
            elif [[ $s == 'refresh.timer' ]]; then
                if [[ $s == $o ]]; then
                    echo "Set $s to $r_timer_sug"
                    # Set refresh.timer to $r_timer_sug.
                    echo "Setting $s to $r_timer_sug..."
                    pkexec "$AS_ROOT" snap set system refresh.timer="$r_timer_sug"
                else
                    continue
                fi
            elif [[ $s == 'refresh.retain' ]]; then
                if [[ $s == $o ]]; then
                    echo "Set $s to $r_kept_sug"
                    # Keep $r_kept_sug number of snap revisions.
                    echo "Setting $s to $r_kept_sug..."
                    pkexec "$AS_ROOT" snap set system refresh.retain="$r_kept_sug"
                else
                    continue
                fi
            else
                continue
            fi
        done
    done

    # Refresh the window to show changes.
    window_settings
}

# Show window of available snaps to update or install.
window_add_or_update_snaps() {
    # This function takes $SNAPS_DIR and $SUM as arguments.
    #   It lets the user install or update snaps both offline and online.
    snaps_dir="$1"
    install_mode="$2"

    # Prepare to add/update snaps from offline source if chosen.
    if [[ ! $install_mode -eq 2 ]]; then
        echo "=== Add/Update Snaps window ===" >> "$LOG"
        list_installed_snaps                                     # -> $snaps_installed
        list_available_snaps "$snaps_dir"                        # -> $snaps_available
        list_updatable_snaps "snaps_installed" "snaps_available" # -> $snaps_updatable

        if [[ $wasta_offline_launch ]]; then
            # Update offline snaps; don't show other available snaps.
            install_snaps "snaps_available" "snaps_updatable" "$snaps_dir" \
                | zenity "${ZDEFAULTS[@]}" "${ZPROGDEFS[@]}" --no-cancel \
                    --text="Waiting for authorization..." 2>/dev/null
        else
            # Show updatable and installable snaps.
            show_offline_updates "snaps_installed" "snaps_available" "snaps_updatable" # -> $selected_snaps

            # Test if $selected_snaps list is empty.
            if [[ ! ${selected_snaps[@]} ]]; then
                # Empty update/install list. Return to main window.
                window_home
            fi

            # Install offline snaps; show progress window.
            install_snaps "snaps_available" "selected_snaps" "$snaps_dir" \
                | zenity "${ZDEFAULTS[@]}" "${ZPROGDEFS[@]}" --no-cancel \
                    --text="Waiting for authorization..." 2>/dev/null
        fi
    fi

    # Refresh snaps if $INET=2; show progress window.
    if [[ $install_mode -gt 1 ]]; then
        #last=$(snap change --last=refresh)
        textA="Updating snaps from the Snap store."
        textB="\n\tThis might take awhile on a slow connection.\n\n"
        echo "$textA" | tee -a "$LOG"
        # TODO: Need some kind of indication of progress?
        pkexec "$AS_ROOT" snap refresh | tee >(zenity "${ZDEFAULTS[@]}" \
            "${ZPROGDEFS[@]}" --text="$textA$textB" 2>/dev/null)
    fi

    # Exit now if launched from wasta-offline.
    if [[ $wasta_offline_launch ]]; then
        # Exit wasta-snap-manager to continue wasta-offline.
        echo "Snap updates complete. Continuing with wasta-offline." >> "$LOG"
        exit 0
    fi

    # Return to Offline Updates Window.
    window_add_or_update_snaps "$snaps_dir" "$install_mode"
}

# Show window of installed snaps & allow for their removal.
window_remove_snaps() {
    # This function takes no arguments. It lets the user uncheck installed
    #   snaps in order to uninstall them. It can also be used to simply show
    #   a list of installed snaps.
    if [[ ! $LOG ]]; then
        create_log
    fi
    echo "=== Remove Snaps window ===" >> "$LOG"
    list_installed_snaps # -> $snaps_installed
    show_installed_snaps "snaps_installed" # -> $snaps_to_remove

    # Test if snaps_to_remove list is empty.
    if [[ ! ${snaps_to_remove[@]} ]]; then
        # Empty removal list. Return to main window.
        window_home
    fi

    # Remove snaps; show progress window.
    remove_snaps "snaps_to_remove" \
        | zenity "${ZDEFAULTS[@]}" "${ZPROGDEFS[@]}" --no-cancel \
            --text="Waiting for authorization..." 2>/dev/null

    # Return to Remove Snaps Window.
    window_remove_snaps
}


# ---------------------------------------------------------------------------
# Main processing.
# ---------------------------------------------------------------------------

# If folder argument is passed, go directly to updating snaps.
#   E.g., if launched from wasta-offline.
if [[ $OFFL -eq 1 ]]; then
    wasta_offline_launch=1
    create_log "$SUM" "$SNAPS_DIR"
    window_add_or_update_snaps "$SNAPS_DIR" "$SUM"
else
    # Launch main window.
    wasta_offline_launch=''
    window_home "$SUM" "$SNAPS_DIR"
fi

exit 0
