#!/bin/bash

# TODO:
#   - Provide output confirming when a snap is installed.
#   - After "Offline" is selected, add a checklist dialog showing available snaps.
#   - Fix "missing" text in initial dialog (probably due to usage of "[...]").
#   - What to do about snaps that require manually plug/slot connections? (Ex.?)
#   - Determine if snapd is installed first. Offer to install it if not.
#   - Will a snap updated from offline properly keep config and data files?
#   - Add ability for user to set the update timer
#       Provide clear guidance on how to sue it.
#       This would effectively prevent unapproved updates.
#       Updates could always be "forced" by the user (aka this script) using
#       the "snap refresh" command.
#   - See also: https://forum.snapcraft.io/t/system-options/87
#           Options: "timer", "metered" connections, # of old versions to "retain"

# ===========================================================================
# Purpose:
#   - Provide for installing, updating, and removing snap packages without
#       an internet connection.
# Goals:
#   - Accept an argument indicating a folder where snaps and asserts are kept.
#   - Guide the user to select such a folder when there is no argument.
#   - Present a list of snaps to install or update, allowing the user to select
#       from among them.
#   - Ensure that the core snap is installed/updated first.
#   - Ensure that snaps will be able to receive automatic updates, as if they
#       were installed directly from the snap store.
#   - Give the user the option of scheduling updates at an obscure time that
#       would effectively disable them, if desired.
#   - Allow the user to limit the number of revisions kept to save disk space.
#   - [...]
# ===========================================================================


# Set global variables.
# ---------------------------------------------------------------------------
USAGE_TEXT="usage: $0 [-h] | [-i] [-s /path/to/dir] [snap name(s)...]"
HELP_TEXT="$USAGE_TEXT

This app updates snap apps. The updates can come from the internet, a directory,
or both. If no options or args are passed, update information will be requested
interactively. If no snap names are given, then updates are attempted for all
installed snaps.
    
    -h                  Show this help text.
    -i                  Search online for updates.
    -s  /path/to/dir    Look for downloaded updates in /path/to/dir.
    snap1 snap2 ...     Space-separated list of snaps to install or update.

"

# Empty intial value for $SNAPS_DIR.
SNAPS_DIR=''

# Initial value for online source.
INET=0
OFFL=0

# Initial value for non-interactive mode.
AUTO=0


# Parse options passed.
# ---------------------------------------------------------------------------
while getopts ":his:" opt; do
    case $opt in
        h) # help requested
            echo "$HELP_TEXT"
            exit 0
            ;;
        i) # check internet for updates
            INET=2
            ;;
        s) # source directory option passed
            SNAPS_DIR=$(realpath "$OPTARG")
            AUTO=1
            OFFL=1
            ;;
        /?) # invalid option
            echo "$USAGE_TEXT"
            exit 1
    esac
done
shift $((OPTIND-1))

# System info
LOG_DATE=$(date +%F-%H-%M)
HOST=$(uname -n)

# Starting value for determining update sources.
SUM=$(($INET + $OFFL))

# Zenity defaults
ZTITLE="Wasta [Snap] Manager"
ZHEIGHT=450
ZWIDTH=650
ZICON=/usr/share/icons/hicolor/64x64/apps/wasta-offline.png
ZICNM=wasta-offline
ZDEFAULTS=(--title="$ZTITLE" --height="$ZHEIGHT" --width="$ZWIDTH" --window-icon="$ZICON" --icon-name="$ZICNM")

# Gain root privileges early on.
AS_ROOT=wasta-snap-manager-root


# Determine update source(s).
# ---------------------------------------------------------------------------
# If source(s) not given in options, ask for them interactively.
while [[ $SUM -eq 0 ]]; do

    text="<big><b>wasta [Snap] Manager</b>
Control the source and timing of snap package updates.</big>

First choose where you'd like to get updates from.

\tIf <i>Offline</i> is chosen, you will be asked to give the folder
\tlocation shortly. A wasta [Offline] folder will be automatically
\tsuggested if found.

\tIf <i>Online</i> is chosen, snap packages will be downloaded from
\tthe Snap Store. Snap pacakges can potentially be hundreds of MB
\teach for the initial install, but updates only download the
\tchanges since the installed version and are smaller.

\tIf both <i>Offline</i> and <i>Online</i> are chosen <b>wasta [Snap] Manager</b>
\twill first install or update snap packages from the offline source,
\tthen look for additional updates or installs from the Snap store in
\torder to minimize the amount of data downloaded.

<b>Choose the source(s) for updating or installing snap packages:</b>"

    list=( "False" "1" "Offline" "wasta [Offline] or local folder" "False" "2" "Online" "Snap store" )
    sources=$(zenity --list --checklist "${ZDEFAULTS[@]}" \
        --column='' --column=value --column=Source --column=Description \
        --hide-column=2 "${list[@]}" \
        --text="$text" 2>/dev/null)

    if [[ $? -ne 0 ]]; then
        # User clicked "Cancel". Exit.
        exit 1
    fi
    
    # Add 0 ouput for unchecked box.
    if [[ $sources -eq 1 ]]; then
        sources="$sources|0"
    elif [[ $sources -eq 2 ]]; then
        sources="0|$sources"
    fi
    
    # Evaluate user's response.
    OFFL="${sources%|*}"
    INET="${sources#*|}"
    
    # Re-evaluate $SUM to either exit or restart loop.
    SUM=$(($INET + $OFFL))
done

# Ask user for offline folder location if not passed as argument.
if [[ ! $SNAPS_DIR ]] && [[ $OFFL -eq 1 ]]; then
    # Determine potential $START_FOLDER.
    text="Searching system for wasta [Offline] folder..."
    prog_opts=(--progress --pulsate --auto-close --auto-kill --no-cancel)
    # Convoluted yet functional zenity subprocess inspired by this article:
    #   http://wiki.bash-hackers.org/zenity_--progress
    wo_list=$(
        find /media /mnt /home/"$USER" -not -path '*/.*' \
            -name 'wasta-offline' -type d 2>/dev/null | tee >(
                zenity "${prog_opts[@]}" --text="$text" "${ZDEFAULTS[@]}" \
                    2>/dev/null
                )
        )
    if [[ -z $wo_list ]]; then
        START_FOLDER=/home/"$USER"/
    else
        for d in ${wo_list[@]}; do
            loc_cache=$(find "$d" -maxdepth 1 -name 'local-cache' -type d 2>/dev/null)
            if [[ $loc_cache =~ ^/media/.*$ ]]; then
                # Automatically accept 'wasta-offline' folder in /media/...
                START_FOLDER="$d"
                # Title for upcoming file chooser dialog.
                title="Confirm the wasta-offline folder or choose another one"
                break
            elif [[ $loc_cache ]]; then
                # Accept other 'wasta-offlne' folder, but let one in /media/... overrule it.
                #   In case there are more than two qualifiers, the last one found wins.
                START_FOLDER="$d"
                title="Confirm the wasta-offline folder or choose another one"
            else
                # No "true" wasta-offline folder found.
                START_FOLDER=/home/"$USER"/
                title="Choose the offline snaps folder"
            fi
        done
    fi
    SNAPS_DIR=$(
        zenity --file-selection --directory --title="$title" \
            --filename="$START_FOLDER" 2>/dev/null
        )
    if [[ $? -ne 0 ]]; then
        # User clicked "Cancel". Exit.
        exit 1
    fi
fi

# Set log location.
#   Needs to happen before $SNAPS_DIR adjustment below.
#   Can't guarantee a $SNAPS_DIR if source is online only.
if [[ $SNAPS_DIR ]]; then
    LOG_DIR="$SNAPS_DIR/log/wasta-snap-manager"
else
    LOG_DIR=/home/$USER/.log/wasta-snap-manager
fi
mkdir -p "$LOG_DIR"
LOG="$LOG_DIR/$LOG_DATE-$HOST.log"

# Need to be able to handle 2 types of SNAPS_DIRs:
#   1. "wasta-offline" folder -> Set SNAPS_DIR as wasta-offline/local-cache/snaps.
#   2. any other folder passed -> Set SNAPS_DIR as passed argument.
if [[ $SNAPS_DIR =~ ^.*wasta-offline$ ]]; then
    SNAPS_DIR="$SNAPS_DIR"/local-cache/snaps
    # Make sure SNAPS_DIR exists.
    mkdir -p "$SNAPS_DIR"
fi

# Initial log entry
echo "-------------------------------------------------------" | tee -a "$LOG"
echo "*** Installing/updating snaps                          " | tee -a "$LOG"
echo "-------------------------------------------------------" | tee -a "$LOG"

# Note defined update source(s).
echo "Update source(s):"                    | tee -a "$LOG"
case $SUM in
    1) # offline updates only
        echo "$SNAPS_DIR"                   | tee -a "$LOG"
        ;;
    2) # online updates only
        echo "Snap store."                  | tee -a "$LOG"
        ;;
    3) # offline and online updates
        echo "$SNAPS_DIR, then Snap store." | tee -a "$LOG"
esac
echo | tee -a "$LOG"



# A. For snaps in $SNAPS_DIR
list_installed_snaps() {
    # Get list of snaps currently installed.
    installed_list=$(snap list | grep -v Name)
    echo -e "Installed snaps:\n$installed_list\n" >> "$LOG"

    # Add these snap names to $snaps_local dictionary.
    declare -Ag snaps_installed
    while read -r line; do
        name=$(echo "$line" | tr -s ' ' | cut -d' ' -f1)
        rev=$(echo "$line" | tr -s ' ' | cut -d' ' -f3)
        #fileloc=$SNAPS/${snap}_${rev}.snap
        #size=$(stat --printf="%s" "$fileloc")
        snaps_installed["$name"]="$rev"
    done <<< "$installed_list"
    }

list_available_snaps() {
    # Get offline snaps in $SNAPS_DIR.
    available_list=$(find "$SNAPS_DIR"/ -name '*.snap')

    # Build associative array of available snaps and revisions in SNAPS_DIR.
    #   The revision numbers are space-delimited; e.g. ("[skype]"="54 57 ").
    declare -A snaps_avail_all
    for i in ${available_list[@]}; do
        name_rev=${i##*/}
        name_rev=${name_rev%.snap}
        rev=${name_rev##*_}
        name=${name_rev%_*}
        snaps_avail_all["$name"]+="$rev "
    done

    # Sort revisions listed for each snap, choose highest one.
    declare -Ag snaps_available
    for name in ${!snaps_avail_all[@]}; do
        top=$(
            for r in ${snaps_avail_all[$name]}; do
                echo $r
            done | sort -nr | head -1
            )
        snaps_available["$name"]="$top"
    done
    }

list_updatable_snaps() {
    declare -n inst="$1"
    declare -n avail="$2"
    
    # Find any $snaps_available newer than $snaps_installed.
    declare -Ag snaps_updatable
    for name in ${!inst[@]}; do
        inst_rev="${inst[$name]}"
        avail_rev="${avail[$name]}"
        if [[ $avail_rev -gt $inst_rev ]]; then
            snaps_updatable[$name]="$avail_rev"
        fi
    done
    }

show_offline_updates() {
    declare -n installed="$1"
    declare -n available="$2"
    declare -n updatable="$3"


    # Build list for displaying updatable and installable snaps.
    avail_unsorted=( ${!available[@]} )
    avail_sorted=( $(printf '%s\n' "${avail_unsorted[@]}" | sort) )

    available_snaps=()
    for name in "${avail_sorted[@]}"; do
        inst_rev="${installed[$name]}"
        avail_rev="${available[$name]}"
        if [[ ${installed[$name]} ]]; then
            if [[ ${updatable[$name]} ]]; then
                available_snaps+=( "True" "$name" "$inst_rev" "$avail_rev" )
            fi
        else
            available_snaps+=( "False" "$name" "-" "$avail_rev" )
        fi
    done

    # Show zenity --checklist for user to choose updates/installs.
    if [[ $available_snaps ]]; then
        text="<big><b>\
Offline snap packages are available for this computer. Do you want to
install them now?</b></big>
Updates are already selected. New packages can be installed by selecting them as well."
        selected_snaps=$(zenity --list --checklist "${ZDEFAULTS[@]}" \
            --title="Wasta [Snap] Manager" --ok-label="Install Now" \
            --column='' --column="Snap" --column="Installed Revision" --column="Available Revision" \
            "${available_snaps[@]}" --separator='\n' \
            --text="$text" 2>/dev/null
            )
        if [[ $? -eq 1 ]]; then
            # User clicked Cancel.
            exit 1
        fi
    else
        text="<big><b>No updated snaps are available.</b></big>"
        zenity --info "${ZDEFAULTS[@]}" --width=350 --height=150 \
                --text="$text" 2>/dev/null
        exit 0
    fi
    }

install_snaps() {
    declare -n available="$1"
    declare -n to_install="$2"
    
    # Elevate to root privileges before installing.
    pkexec "$AS_ROOT" elevate
    if [[ $? -eq 126 ]]; then
        # Installation cancelled.
        exit 1
    fi

    for name in ${to_install[@]}; do
        rev="${available[$name]}"

        # Output to progress dialog and to $LOG.
        echo "#Installing/updating snaps from:\n\t$SNAPS_DIR\n\n$name..."
        echo -en "\tInstalling $name from offline source... " | tee -a "$LOG"
        # Acknowledge assertion.
        pkexec "$AS_ROOT" snap ack "$SNAPS_DIR/${name}_${rev}.assert" 2>"$LOG"
        #--------------------------------------------------------------
        # Unfortunately, to find out if a downloaded snap requires 
        # --classic confinement there seems to be two options:
        #       1. Install the snap first and let it fail, grep for
        #           'classic' in the error output
        #       2. Mount the snap file, cat /meta/snap.yaml, grep
        #           'confinement: classic', umount the image.
        # -------------------------------------------------------------
        # Install snap. Check change to see if error due to --classic flag.
        pkexec "$AS_ROOT" snap install "$SNAPS_DIR/${name}_${rev}.snap" 2>"$LOG"
        if [[ $? -gt 0 ]]; then # failed to install
            change=$(snap changes | tail -n2 | head -1 | tr -s ' ' \
                | cut -d' ' -f1)
            # TODO: Does this work for other locales?
            needs_classic=$(snap change "$change" | tail -n2 | head -1 \
                | grep 'requires classic confinement') 
            if [[ $needs_classic ]]; then
                # Attempt install again with --classic flag.
                echo "$needs_classic" | tee -a "$LOG"
                pkexec "$AS_ROOT" snap install $SNAPS_DIR/${name}_${rev}.snap --classic
                if [[ $? -ne 0 ]]; then
                    # Unhandled error.
                    echo -e "\tUnhandled error. Skipped." | tee -a "$LOG"
                    continue
                else
                    echo -e "\t$snap installed." | tee -a "$LOG"
                fi
            else
                # Some other install error.
                echo "Error: skipping. " | tee -a "$LOG"
                continue
            fi
        fi
    done
    }


# Show window of available updates, à la update-manager.
# ---------------------------------------------------------------------------
list_installed_snaps                                     # -> $snaps_installed
list_available_snaps                                     # -> $snaps_available
list_updatable_snaps "snaps_installed" "snaps_available" # -> $snaps_updatable
show_offline_updates "snaps_installed" "snaps_available" "snaps_updatable" # -> $selected_snaps

# Install offline snaps; show progress window.
prog_opts=(--progress --pulsate --auto-close --no-cancel)
install_snaps "snaps_available" "selected_snaps" \
    | zenity "${prog_opts[@]}" "${ZDEFAULTS[@]}" --height=250 \
        --text="Waiting for authorization..." 2>/dev/null


#############################################################################
#############################################################################
# B. For online snaps.


#echo "${selected_updates[@]}"
exit 0
#############################################################################
#############################################################################

# Determine list of snaps to update or install.
# ---------------------------------------------------------------------------
if [[ $@ ]]; then
    # Including core snaps in case they aren't yet installed or up-to-date.
    update_list="core core18 $@"
else # Get list of all installed snaps for updating.
    update_list=$(snap list | grep -v Name | grep -v disabled \
        | tr -s ' ' | cut -d' ' -f1)
fi

# Parse info for snaps to be installed or updated.
for snap in $update_list; do
    echo -n "Checking $snap... " | tee -a "$LOG"
    
    # Get local installed status and revision info.
    inst_rev=0

    # Command block around command substitution allows to send the output of 
    #   the command to both stdout (via /dev/fd/5) AND assign it to a variable.
    #   https://stackoverflow.com/questions/12451278/capture-stdout-to-a-variable-but-still-display-it-in-the-console
    {
    inst_info=$(
        # Using tee to send /dev/fd/1 both to zenity progress and /dev/fd/5.
        snap info $snap 2>/dev/null | grep -v disabled | grep 'installed:' \
        | tee >(zenity --progress --pulsate --auto-close "${ZDEFAULTS[@]}" \
            --text="Checking $snap install status..." 2>/dev/null) \
            /dev/fd/5
        )
    # Redirect /dev/fd/5 to /dev/fd/1 to "export" variables from command block.
    } 5>&1
    
    if [[ $inst_info ]]; then
        # Snap is installed.
        inst_status=1
        inst_rev=$(echo $inst_info | sed -r 's/.*\(([0-9]*)\).*/\1/')
    else # snap not installed
        echo "not installed." | tee -a "$LOG"
        inst_status=0
    fi
    
    # If offline mode selected, update/install from $SNAPS_DIR if available.
    #   If online mode is also chosen, this could lead to a snap being updated
    #   twice, but that should also reduce the amount needed to be downloaded
    #   since it will only download delta changes since the offline version.
    if [[ $OFFL -eq 1 ]]; then
        # List all revisions of current snap.
        filepaths=$(find $SNAPS_DIR/${snap}_*.snap 2>/dev/null)
        ec=$?

        # Choosing the last entry found ensures the highest revision number.
        filepath=$(echo "$filepaths" | tail -n1)
        if [[ $ec -eq 0 ]]; then # snap found in $SNAPS_DIR
            # Get snap revision #.
            filename=${filepath##*/}
            snap_rev=${filename%.*}
            offl_rev=${snap_rev##*_}
            if [[ $inst_status -eq 0 ]]; then
                # Command block for zenity progress.
                {
                echo "#Installing $snap from $SNAPS_DIR... "
                # Need to install snap.
                echo -en "\tInstalling $snap from local source... " | tee -a "$LOG"
                snap ack $SNAPS_DIR/${snap}_${offl_rev}.assert
                #--------------------------------------------------------------
                # Unfortunately, to find out if a downloaded snap requires 
                # --classic confinement there seems to be two options:
                #       1. Install the snap first and let it fail, grep for
                #           'classic' in the error output
                #       2. Mount the snap file, cat /meta/snap.yaml, grep
                #           'confinement: classic', umount the image.
                # -------------------------------------------------------------
                # Install snap. Check change to see if error due to --classic flag.
                snap install $SNAPS_DIR/${snap}_${offl_rev}.snap
                if [[ $? -gt 0 ]]; then # failed to install
                    change=$(snap changes | tail -n2 | head -1 | tr -s ' ' \
                        | cut -d' ' -f1)
                    # TODO: Does this work for other locales?
                    needs_classic=$(snap change "$change" | tail -n2 | head -1 \
                        | grep 'requires classic confinement') 
                    if [[ $needs_classic ]]; then
                        # Attempt install again with --classic flag.
                        echo "$needs_classic" | tee -a "$LOG"
                        snap install $SNAPS_DIR/${snap}_${offl_rev}.snap --classic
                        if [[ $? -ne 0 ]]; then
                            # Unhandled error.
                            echo -e "\tUnhandled error. Skipped." | tee -a "$LOG"
                            continue
                        else
                            echo -e "\t$snap installed." | tee -a "$LOG"
                        fi
                    else
                        # Some other install error.
                        echo "Error: skipping. " | tee -a "$LOG"
                        continue
                    fi
                fi
                } | zenity --progress --pulsate --auto-close "${ZDEFAULTS[@]}" 2>/dev/null
                inst_status=1
                inst_rev=$offl_rev
            else
                {
                echo "#Updating $snap from $SNAPS_DIR... "
                if [[ $offl_rev -gt $inst_rev ]]; then
                    # TODO: Test if this actually works when user data is involved.
                    echo -en "\tUpdating $snap from local source..." | tee -a "$LOG"
                    snap ack "$SNAPS_DIR/${snap}_${offl_rev}.assert"
                    # TODO: Does this work with a --classic snap update? (skype, snapcraft)
                    snap install "$SNAPS_DIR/${snap}_${offl_rev}.snap"
                else
                    echo -en "\tNo local updates available. " | tee -a "$LOG"
                    # Give enough time for the user to see it looking for an update.
                    sleep 1.5
                fi
                } | zenity --progress --pulsate --auto-close "${ZDEFAULTS[@]}" 2>/dev/null
            fi
        else # not found in $SNAPS_DIR
            echo -en "\tNo local updates available. " | tee -a "$LOG"
        fi
    fi

    # If online mode is selected, update/install from internet if available.
    if [[ $INET -eq 2 ]]; then
        # Get latest stable revision number online.
        inet_info=$(snap info "$snap" | grep ' stable:')
        ec=$?
        # Determine confinement and install/update snap.
        if [[ $ec -eq 0 ]]; then # snap found online
            # Determine if snap requires classic confinement (ala skype)
            if [[ $(echo "$inet_info" | grep classic) ]]; then
                confinement="--classic"
            else
                confinement=''
            fi

            if [[ $inst_status -eq 1 ]]; then
                {
                echo "#Updating $snap from Snap store... "
                # Snap is already installed. It just needs to be "refreshed".
                echo "Updating $snap from the Snap store..." | tee -a "$LOG"
                snap refresh "$snap"
                } | zenity --progress --pulsate --auto-close "${ZDEFAULTS[@]}" 2>/dev/null
            else
                {
                # Snap is not installed.
                echo "#Installing $snap from the Snap store..."
                echo "Installing $snap from the Snap store..." | tee -a "$LOG"
                if [[ $confinement ]]; then
                    snap install "$snap" "$confinement"
                else
                    snap install "$snap"
                fi
                } | zenity --progress --pulsate --auto-close "${ZDEFAULTS[@]}" 2>/dev/null
            fi
        else
            # Snap not found. No internet connection? Snap not available?
            echo "Error: $snap not found." | tee -a "$LOG"
            exit 1
        fi
    else
        echo | tee -a "$LOG" # adds final \n to output
    fi
done


exit 0
